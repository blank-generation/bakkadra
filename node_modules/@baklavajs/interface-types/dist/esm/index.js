/**
 * @module @baklavajs/interface-types
 */
export class NodeInterfaceType {
    constructor(name) {
        this.name = name;
        this.conversions = [];
    }
    /**
     * A conversion makes it possible to connect two node interfaces although they have different types.
     * @param to Type to convert to
     * @param transformationFunction
     * Will be called to transform the value from one type to another.
     * A transformation to convert the type `string` to `number` could be `parseInt`.
     *
     * @returns the instance the method was called on for chaining
     */
    addConversion(to, transformationFunction = (value) => value) {
        this.conversions.push({
            targetType: to.name,
            transformationFunction,
        });
        return this;
    }
}
export function setType(intf, type) {
    intf.type = type.name;
}
/** Use this function to set the type for a NodeInterface with `allowMultipleConnections` */
export function setTypeForMultipleConnections(intf, type) {
    intf.type = type.name;
}
export function getType(intf) {
    return intf.type;
}
export class BaklavaInterfaceTypes {
    constructor(editor, options) {
        this.types = new Map();
        this.editor = editor;
        this.editor.graphEvents.checkConnection.subscribe(this, ({ from, to }, prevent) => {
            const fromType = from.type;
            const toType = to.type;
            if (!fromType || !toType) {
                return;
            }
            else if (!this.canConvert(fromType, toType)) {
                return prevent();
            }
        });
        if (options === null || options === void 0 ? void 0 : options.engine) {
            options.engine.hooks.transferData.subscribe(this, (value, connection) => {
                const fromType = connection.from.type;
                const toType = connection.to.type;
                if (!fromType || !toType) {
                    return value;
                }
                return this.convert(fromType, toType, value);
            });
        }
        if (options === null || options === void 0 ? void 0 : options.viewPlugin) {
            options.viewPlugin.hooks.renderInterface.subscribe(this, ({ intf, el }) => {
                if (intf.type) {
                    el.setAttribute("data-interface-type", intf.type);
                }
                return { intf, el };
            });
        }
    }
    /**
     * Add a new node interface type
     * @param types The types to add
     */
    addTypes(...types) {
        types.forEach((t) => {
            this.types.set(t.name, t);
        });
        return this;
    }
    getConversion(from, to) {
        var _a, _b;
        return (_b = (_a = this.types.get(from)) === null || _a === void 0 ? void 0 : _a.conversions.find((c) => c.targetType === to)) !== null && _b !== void 0 ? _b : null;
    }
    canConvert(from, to) {
        return (from === to || (this.types.has(from) && this.types.get(from).conversions.some((c) => c.targetType === to)));
    }
    convert(from, to, value) {
        if (from === to) {
            return value;
        }
        else {
            const c = this.getConversion(from, to);
            if (c) {
                return c.transformationFunction(value);
            }
            else {
                throw Error(`Can not convert from "${from}" to "${to}"`);
            }
        }
    }
}
