/**
 * @module @baklavajs/interface-types
 */
import type { Editor, NodeInterface } from "@baklavajs/core";
import type { IBaklavaViewModel } from "@baklavajs/renderer-vue";
import type { BaseEngine } from "@baklavajs/engine";
export interface IConversion<I, O> {
    targetType: string;
    transformationFunction(value: I): O;
}
export interface BaklavaInterfaceTypesOptions {
    viewPlugin?: IBaklavaViewModel;
    engine?: BaseEngine<any, any>;
}
export declare class NodeInterfaceType<T> {
    name: string;
    conversions: Array<IConversion<T, any>>;
    constructor(name: string);
    /**
     * A conversion makes it possible to connect two node interfaces although they have different types.
     * @param to Type to convert to
     * @param transformationFunction
     * Will be called to transform the value from one type to another.
     * A transformation to convert the type `string` to `number` could be `parseInt`.
     *
     * @returns the instance the method was called on for chaining
     */
    addConversion<O>(to: NodeInterfaceType<O>, transformationFunction?: (value: T) => O): this;
}
export declare function setType<T>(intf: NodeInterface<T>, type: NodeInterfaceType<T>): void;
/** Use this function to set the type for a NodeInterface with `allowMultipleConnections` */
export declare function setTypeForMultipleConnections<T>(intf: NodeInterface<T[]>, type: NodeInterfaceType<T>): void;
export declare function getType<T>(intf: NodeInterface<T>): string | undefined;
export declare class BaklavaInterfaceTypes {
    private editor;
    private types;
    constructor(editor: Editor, options?: BaklavaInterfaceTypesOptions);
    /**
     * Add a new node interface type
     * @param types The types to add
     */
    addTypes(...types: Array<NodeInterfaceType<unknown>>): this;
    getConversion<I = any, O = any>(from: string, to: string): IConversion<I, O> | null;
    canConvert(from: string, to: string): boolean;
    convert<I = any, O = any>(from: string, to: string, value: I): O;
}
