"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GRAPH_NODE_TYPE_PREFIX = void 0;
exports.getGraphNodeTypeString = getGraphNodeTypeString;
exports.createGraphNodeType = createGraphNodeType;
const graphInterface_1 = require("./graphInterface");
const node_1 = require("./node");
const nodeInterface_1 = require("./nodeInterface");
exports.GRAPH_NODE_TYPE_PREFIX = "__baklava_GraphNode-";
function getGraphNodeTypeString(template) {
    return exports.GRAPH_NODE_TYPE_PREFIX + template.id;
}
/** Properties that should not be proxied to the original interface */
const PROXY_INTERFACE_SKIP_PROPERTIES = [
    "component",
    "connectionCount",
    "events",
    "hidden",
    "hooks",
    "id",
    "isInput",
    "name",
    "nodeId",
    "port",
    "templateId",
    "value",
];
function createGraphNodeType(template) {
    return class GraphNode extends node_1.AbstractNode {
        constructor() {
            super(...arguments);
            this.type = getGraphNodeTypeString(template);
            this.inputs = {};
            this.outputs = {};
            this.template = template;
            this.calculate = async (inputs, context) => {
                var _a;
                if (!this.subgraph) {
                    throw new Error(`GraphNode ${this.id}: calculate called without subgraph being initialized`);
                }
                if (!context.engine || typeof context.engine !== "object") {
                    throw new Error(`GraphNode ${this.id}: calculate called but no engine provided in context`);
                }
                const graphInputs = context.engine.getInputValues(this.subgraph);
                // fill subgraph input placeholders
                for (const input of this.subgraph.inputs) {
                    graphInputs.set(input.nodeInterfaceId, inputs[input.id]);
                }
                const result = await context.engine.runGraph(this.subgraph, graphInputs, context.globalValues);
                const outputs = {};
                for (const output of this.subgraph.outputs) {
                    outputs[output.id] = (_a = result.get(output.nodeId)) === null || _a === void 0 ? void 0 : _a.get("output");
                }
                outputs._calculationResults = result;
                return outputs;
            };
        }
        get title() {
            return this._title;
        }
        set title(v) {
            this.template.name = v;
        }
        load(state) {
            if (!this.subgraph) {
                throw new Error("Cannot load a graph node without a graph");
            }
            if (!this.template) {
                throw new Error("Unable to load graph node without graph template");
            }
            this.subgraph.load(state.graphState);
            super.load(state);
        }
        save() {
            if (!this.subgraph) {
                throw new Error("Cannot save a graph node without a graph");
            }
            const state = super.save();
            return {
                ...state,
                graphState: this.subgraph.save(),
            };
        }
        onPlaced() {
            this.template.events.updated.subscribe(this, () => this.initialize());
            this.template.events.nameChanged.subscribe(this, (name) => {
                this._title = name;
            });
            this.initialize();
        }
        onDestroy() {
            var _a;
            this.template.events.updated.unsubscribe(this);
            this.template.events.nameChanged.unsubscribe(this);
            (_a = this.subgraph) === null || _a === void 0 ? void 0 : _a.destroy();
        }
        initialize() {
            if (this.subgraph) {
                this.subgraph.destroy();
            }
            this.subgraph = this.template.createGraph();
            this._title = this.template.name;
            this.updateInterfaces();
            this.events.update.emit(null);
        }
        updateInterfaces() {
            if (!this.subgraph) {
                throw new Error("Trying to update interfaces without graph instance");
            }
            for (const graphInput of this.subgraph.inputs) {
                if (!(graphInput.id in this.inputs)) {
                    this.addInput(graphInput.id, this.createProxyInterface(graphInput, true));
                }
                else {
                    this.inputs[graphInput.id].name = graphInput.name;
                }
            }
            for (const k of Object.keys(this.inputs)) {
                if (!this.subgraph.inputs.some((gi) => gi.id === k)) {
                    this.removeInput(k);
                }
            }
            for (const graphOutput of this.subgraph.outputs) {
                if (!(graphOutput.id in this.outputs)) {
                    this.addOutput(graphOutput.id, this.createProxyInterface(graphOutput, false));
                }
                else {
                    this.outputs[graphOutput.id].name = graphOutput.name;
                }
            }
            for (const k of Object.keys(this.outputs)) {
                if (!this.subgraph.outputs.some((gi) => gi.id === k)) {
                    this.removeOutput(k);
                }
            }
            // Add an internal output to allow accessing the calculation results of nodes inside the graph
            this.addOutput("_calculationResults", new nodeInterface_1.NodeInterface("_calculationResults", undefined).setHidden(true));
        }
        /**
         * When we create a interface in the graph node, we hide certain properties of the interface in the subgraph.
         * For example, the `type` property or the `allowMultipleConnections` property.
         * These properties should be proxied to the subgraph interface, so they behave the same as the original interface.
         */
        createProxyInterface(graphInterface, isInput) {
            const newInterface = new nodeInterface_1.NodeInterface(graphInterface.name, undefined);
            return new Proxy(newInterface, {
                get: (target, prop) => {
                    var _a, _b, _c;
                    // we can't proxy the "__v_isRef" property, otherwise we get a maximum stack size exceeded error
                    if (PROXY_INTERFACE_SKIP_PROPERTIES.includes(prop) ||
                        prop in target ||
                        (typeof prop === "string" && prop.startsWith("__v_"))) {
                        return Reflect.get(target, prop);
                    }
                    // try to find the interface connected to our graph input
                    let placeholderIntfId;
                    if (isInput) {
                        const subgraphInterfaceNode = (_a = this.subgraph) === null || _a === void 0 ? void 0 : _a.nodes.find((n) => graphInterface_1.GraphInputNode.isGraphInputNode(n) && n.graphInterfaceId === graphInterface.id);
                        placeholderIntfId = subgraphInterfaceNode === null || subgraphInterfaceNode === void 0 ? void 0 : subgraphInterfaceNode.outputs.placeholder.id;
                    }
                    else {
                        const subgraphInterfaceNode = (_b = this.subgraph) === null || _b === void 0 ? void 0 : _b.nodes.find((n) => graphInterface_1.GraphOutputNode.isGraphOutputNode(n) && n.graphInterfaceId === graphInterface.id);
                        placeholderIntfId = subgraphInterfaceNode === null || subgraphInterfaceNode === void 0 ? void 0 : subgraphInterfaceNode.inputs.placeholder.id;
                    }
                    const conn = (_c = this.subgraph) === null || _c === void 0 ? void 0 : _c.connections.find((c) => { var _a; return placeholderIntfId === ((_a = (isInput ? c.from : c.to)) === null || _a === void 0 ? void 0 : _a.id); });
                    const intf = isInput ? conn === null || conn === void 0 ? void 0 : conn.to : conn === null || conn === void 0 ? void 0 : conn.from;
                    if (intf) {
                        return Reflect.get(intf, prop);
                    }
                    return undefined;
                },
            });
        }
    };
}
