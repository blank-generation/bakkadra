"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphTemplate = void 0;
const uuid_1 = require("uuid");
const events_1 = require("@baklavajs/events");
const graph_1 = require("./graph");
const utils_1 = require("./utils");
const graphNode_1 = require("./graphNode");
const graphInterface_1 = require("./graphInterface");
class GraphTemplate {
    /** Create a new GraphTemplate from the nodes and connections inside the graph instance */
    static fromGraph(graph, editor) {
        return new GraphTemplate(graph.save(), editor);
    }
    /** Get the name of the graph template */
    get name() {
        return this._name;
    }
    /** Set the name of the graph template */
    set name(v) {
        this._name = v;
        this.events.nameChanged.emit(v);
        const nt = this.editor.nodeTypes.get((0, graphNode_1.getGraphNodeTypeString)(this));
        if (nt) {
            nt.title = v;
        }
    }
    /** List of all inputs to the graph template */
    get inputs() {
        const inputNodes = this.nodes.filter((n) => n.type === graphInterface_1.GRAPH_INPUT_NODE_TYPE);
        return inputNodes.map((n) => ({
            id: n.graphInterfaceId,
            name: n.inputs.name.value,
            nodeId: n.id,
            nodeInterfaceId: n.outputs.placeholder.id,
        }));
    }
    /** List of all outputs of the graph template */
    get outputs() {
        const outputNodes = this.nodes.filter((n) => n.type === graphInterface_1.GRAPH_OUTPUT_NODE_TYPE);
        return outputNodes.map((n) => ({
            id: n.graphInterfaceId,
            name: n.inputs.name.value,
            nodeId: n.id,
            nodeInterfaceId: n.outputs.output.id,
        }));
    }
    constructor(state, editor) {
        /** Graph template id */
        this.id = (0, uuid_1.v4)();
        this._name = "Subgraph";
        this.events = {
            nameChanged: new events_1.BaklavaEvent(this),
            updated: new events_1.BaklavaEvent(this),
        };
        this.hooks = {
            beforeLoad: new events_1.SequentialHook(this),
            afterSave: new events_1.SequentialHook(this),
        };
        this.editor = editor;
        if (state.id) {
            this.id = state.id;
        }
        if (state.name) {
            this._name = state.name;
        }
        this.update(state);
    }
    /** Update the state of the graph template with the provided state */
    update(state) {
        this.nodes = state.nodes;
        this.connections = state.connections;
        this.events.updated.emit();
    }
    save() {
        return {
            id: this.id,
            name: this.name,
            nodes: this.nodes,
            connections: this.connections,
            inputs: this.inputs,
            outputs: this.outputs,
        };
    }
    /**
     * Create a new graph instance from this template
     * or load the state into the provided graph instance.
     */
    createGraph(graph) {
        const idMap = new Map();
        const createNewId = (oldId) => {
            const newId = (0, uuid_1.v4)();
            idMap.set(oldId, newId);
            return newId;
        };
        const getNewId = (oldId) => {
            const newId = idMap.get(oldId);
            if (!newId) {
                throw new Error(`Unable to create graph from template: Could not map old id ${oldId} to new id`);
            }
            return newId;
        };
        const mapNodeInterfaceIds = (interfaceStates) => {
            return (0, utils_1.mapValues)(interfaceStates, (intf) => {
                const clonedIntf = {
                    id: createNewId(intf.id),
                    templateId: intf.id,
                    value: intf.value,
                };
                return clonedIntf;
            });
        };
        const nodes = this.nodes.map((n) => ({
            ...n,
            id: createNewId(n.id),
            inputs: mapNodeInterfaceIds(n.inputs),
            outputs: mapNodeInterfaceIds(n.outputs),
        }));
        const connections = this.connections.map((c) => ({
            id: createNewId(c.id),
            from: getNewId(c.from),
            to: getNewId(c.to),
        }));
        const inputs = this.inputs.map((i) => ({
            id: i.id,
            name: i.name,
            nodeId: getNewId(i.nodeId),
            nodeInterfaceId: getNewId(i.nodeInterfaceId),
        }));
        const outputs = this.outputs.map((o) => ({
            id: o.id,
            name: o.name,
            nodeId: getNewId(o.nodeId),
            nodeInterfaceId: getNewId(o.nodeInterfaceId),
        }));
        const clonedState = {
            id: (0, uuid_1.v4)(),
            nodes,
            connections,
            inputs,
            outputs,
        };
        if (!graph) {
            graph = new graph_1.Graph(this.editor);
        }
        const warnings = graph.load(clonedState);
        warnings.forEach((w) => console.warn(w));
        graph.template = this;
        return graph;
    }
}
exports.GraphTemplate = GraphTemplate;
