import { Node } from "./node";
/**
 * @internal
 * Abstract base class for every dynamic node
 */
export class DynamicNode extends Node {
}
export function defineDynamicNode(definition) {
    return class extends DynamicNode {
        constructor() {
            var _a, _b, _c, _d;
            super();
            this.type = definition.type;
            this.inputs = {};
            this.outputs = {};
            this.preventUpdate = false;
            this.staticInputKeys = Object.keys((_a = definition.inputs) !== null && _a !== void 0 ? _a : {});
            this.staticOutputKeys = Object.keys((_b = definition.outputs) !== null && _b !== void 0 ? _b : {});
            this._title = (_c = definition.title) !== null && _c !== void 0 ? _c : definition.type;
            this.executeFactory("input", definition.inputs);
            this.executeFactory("output", definition.outputs);
            if (definition.calculate) {
                this.calculate = (inputs, globalValues) => { var _a; return (_a = definition.calculate) === null || _a === void 0 ? void 0 : _a.call(this, inputs, globalValues); };
            }
            (_d = definition.onCreate) === null || _d === void 0 ? void 0 : _d.call(this);
        }
        onPlaced() {
            var _a;
            this.events.update.subscribe(this, (data) => {
                if (!data) {
                    return;
                }
                if ((data.type === "input" && this.staticInputKeys.includes(data.name)) ||
                    (data.type === "output" && this.staticOutputKeys.includes(data.name))) {
                    this.onUpdate();
                }
            });
            this.onUpdate();
            (_a = definition.onPlaced) === null || _a === void 0 ? void 0 : _a.call(this);
        }
        onDestroy() {
            var _a;
            (_a = definition.onDestroy) === null || _a === void 0 ? void 0 : _a.call(this);
        }
        load(state) {
            // prevent automatic updates during loading
            this.preventUpdate = true;
            this.hooks.beforeLoad.execute(state);
            this.id = state.id;
            this.title = state.title;
            // first load the state for the static interfaces
            for (const k of this.staticInputKeys) {
                this.inputs[k].load(state.inputs[k]);
                this.inputs[k].nodeId = this.id;
            }
            for (const k of this.staticOutputKeys) {
                this.outputs[k].load(state.outputs[k]);
                this.outputs[k].nodeId = this.id;
            }
            // run the update function to correctly generate all interfaces
            this.preventUpdate = false;
            this.onUpdate();
            this.preventUpdate = true;
            // load the state for all generated interfaces
            for (const k of Object.keys(state.inputs)) {
                if (!this.staticInputKeys.includes(k)) {
                    this.inputs[k].load(state.inputs[k]);
                    this.inputs[k].nodeId = this.id;
                }
            }
            for (const k of Object.keys(state.outputs)) {
                if (!this.staticOutputKeys.includes(k)) {
                    this.outputs[k].load(state.outputs[k]);
                    this.outputs[k].nodeId = this.id;
                }
            }
            this.preventUpdate = false;
            this.events.loaded.emit(this);
        }
        onUpdate() {
            var _a, _b, _c, _d;
            if (this.preventUpdate) {
                return;
            }
            if (this.graph) {
                this.graph.activeTransactions++;
            }
            const inputValues = this.getStaticValues(this.staticInputKeys, this.inputs);
            const outputValues = this.getStaticValues(this.staticOutputKeys, this.outputs);
            const result = definition.onUpdate.call(this, inputValues, outputValues);
            this.updateInterfaces("input", (_a = result.inputs) !== null && _a !== void 0 ? _a : {}, (_b = result.forceUpdateInputs) !== null && _b !== void 0 ? _b : []);
            this.updateInterfaces("output", (_c = result.outputs) !== null && _c !== void 0 ? _c : {}, (_d = result.forceUpdateOutputs) !== null && _d !== void 0 ? _d : []);
            if (this.graph) {
                this.graph.activeTransactions--;
            }
        }
        getStaticValues(keys, interfaces) {
            const values = {};
            for (const k of keys) {
                values[k] = interfaces[k].value;
            }
            return values;
        }
        updateInterfaces(type, newInterfaces, forceUpdates) {
            const staticKeys = type === "input" ? this.staticInputKeys : this.staticOutputKeys;
            const currentInterfaces = type === "input" ? this.inputs : this.outputs;
            // remove all interfaces that are outdated
            for (const k of Object.keys(currentInterfaces)) {
                if (staticKeys.includes(k) || (newInterfaces[k] && !forceUpdates.includes(k))) {
                    continue;
                }
                if (type === "input") {
                    this.removeInput(k);
                }
                else {
                    this.removeOutput(k);
                }
            }
            // add all new interfaces
            for (const k of Object.keys(newInterfaces)) {
                if (currentInterfaces[k]) {
                    continue;
                }
                const intf = newInterfaces[k]();
                if (type === "input") {
                    this.addInput(k, intf);
                }
                else {
                    this.addOutput(k, intf);
                }
            }
        }
        executeFactory(type, factory) {
            Object.keys(factory || {}).forEach((k) => {
                const intf = factory[k]();
                if (type === "input") {
                    this.addInput(k, intf);
                }
                else {
                    this.addOutput(k, intf);
                }
            });
        }
    };
}
