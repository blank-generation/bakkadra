import { v4 as uuidv4 } from "uuid";
import { PreventableBaklavaEvent, BaklavaEvent, SequentialHook, } from "@baklavajs/events";
import { mapValues } from "./utils";
export class AbstractNode {
    constructor() {
        this._title = "";
        /** Unique identifier of the node */
        this.id = uuidv4();
        this.events = {
            loaded: new BaklavaEvent(this),
            beforeAddInput: new PreventableBaklavaEvent(this),
            addInput: new BaklavaEvent(this),
            beforeRemoveInput: new PreventableBaklavaEvent(this),
            removeInput: new BaklavaEvent(this),
            beforeAddOutput: new PreventableBaklavaEvent(this),
            addOutput: new BaklavaEvent(this),
            beforeRemoveOutput: new PreventableBaklavaEvent(this),
            removeOutput: new BaklavaEvent(this),
            beforeTitleChanged: new PreventableBaklavaEvent(this),
            titleChanged: new BaklavaEvent(this),
            update: new BaklavaEvent(this),
        };
        this.hooks = {
            beforeLoad: new SequentialHook(this),
            afterSave: new SequentialHook(this),
        };
    }
    /**
     * The graph instance the node is placed in.
     * `undefined` if the node hasn't been placed in a graph yet.
     */
    get graph() {
        return this.graphInstance;
    }
    /** Customizable display name of the node. */
    get title() {
        return this._title;
    }
    set title(v) {
        if (!this.events.beforeTitleChanged.emit(v).prevented) {
            this._title = v;
            this.events.titleChanged.emit(v);
        }
    }
    /**
     * Add an input interface to the node
     * @param key Key of the input
     * @param input The input instance
     * @returns True when the input was added, otherwise false (prevented by an event handler)
     */
    addInput(key, input) {
        return this.addInterface("input", key, input);
    }
    /**
     * Add an output interface to the node
     * @param key Key of the output
     * @param output The output instance
     * @returns True when the output was added, otherwise false (prevented by an event handler)
     */
    addOutput(key, output) {
        return this.addInterface("output", key, output);
    }
    /**
     * Remove an existing input
     * @param key Key of the input.
     */
    removeInput(key) {
        return this.removeInterface("input", key);
    }
    /**
     * Remove an existing output
     * @param key Key of the output.
     */
    removeOutput(key) {
        return this.removeInterface("output", key);
    }
    /**
     * This function will automatically be called as soon as the node is added to a graph.
     * @param editor Graph instance
     */
    registerGraph(graph) {
        this.graphInstance = graph;
    }
    load(state) {
        this.hooks.beforeLoad.execute(state);
        this.id = state.id;
        this._title = state.title;
        Object.entries(state.inputs).forEach(([k, v]) => {
            if (this.inputs[k]) {
                this.inputs[k].load(v);
                this.inputs[k].nodeId = this.id;
            }
        });
        Object.entries(state.outputs).forEach(([k, v]) => {
            if (this.outputs[k]) {
                this.outputs[k].load(v);
                this.outputs[k].nodeId = this.id;
            }
        });
        this.events.loaded.emit(this);
    }
    save() {
        const inputStates = mapValues(this.inputs, (intf) => intf.save());
        const outputStates = mapValues(this.outputs, (intf) => intf.save());
        const state = {
            type: this.type,
            id: this.id,
            title: this.title,
            inputs: inputStates,
            outputs: outputStates,
        };
        return this.hooks.afterSave.execute(state);
    }
    /**
     * @virtual
     * Override this method to execute logic when the node is placed inside a graph
     */
    onPlaced() { }
    /**
     * @virtual
     * Override this method to perform cleanup when the node is deleted
     */
    onDestroy() { }
    initializeIo() {
        Object.entries(this.inputs).forEach(([key, intf]) => this.initializeIntf("input", key, intf));
        Object.entries(this.outputs).forEach(([key, intf]) => this.initializeIntf("output", key, intf));
    }
    initializeIntf(type, key, intf) {
        intf.isInput = type === "input";
        intf.nodeId = this.id;
        intf.events.setValue.subscribe(this, () => this.events.update.emit({ type, name: key, intf }));
    }
    addInterface(type, key, intf) {
        const beforeEvent = type === "input" ? this.events.beforeAddInput : this.events.beforeAddOutput;
        const afterEvent = type === "input" ? this.events.addInput : this.events.addOutput;
        const ioObject = type === "input" ? this.inputs : this.outputs;
        if (beforeEvent.emit(intf).prevented) {
            return false;
        }
        ioObject[key] = intf;
        this.initializeIntf(type, key, intf);
        afterEvent.emit(intf);
        return true;
    }
    removeInterface(type, key) {
        const beforeEvent = type === "input" ? this.events.beforeRemoveInput : this.events.beforeRemoveOutput;
        const afterEvent = type === "input" ? this.events.removeInput : this.events.removeOutput;
        const io = type === "input" ? this.inputs[key] : this.outputs[key];
        if (!io || beforeEvent.emit(io).prevented) {
            return false;
        }
        if (io.connectionCount > 0) {
            if (this.graphInstance) {
                const connections = this.graphInstance.connections.filter((c) => c.from === io || c.to === io);
                connections.forEach((c) => {
                    this.graphInstance.removeConnection(c);
                });
            }
            else {
                throw new Error("Interface is connected, but no graph instance is specified. Unable to delete interface");
            }
        }
        io.events.setValue.unsubscribe(this);
        if (type === "input") {
            delete this.inputs[key];
        }
        else {
            delete this.outputs[key];
        }
        afterEvent.emit(io);
        return true;
    }
}
/**
 * Abstract base class for every node
 */
export class Node extends AbstractNode {
    load(state) {
        super.load(state);
    }
    save() {
        return super.save();
    }
}
