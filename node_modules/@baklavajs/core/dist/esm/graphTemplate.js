import { v4 as uuidv4 } from "uuid";
import { BaklavaEvent, SequentialHook } from "@baklavajs/events";
import { Graph } from "./graph";
import { mapValues } from "./utils";
import { getGraphNodeTypeString } from "./graphNode";
import { GRAPH_INPUT_NODE_TYPE, GRAPH_OUTPUT_NODE_TYPE, } from "./graphInterface";
export class GraphTemplate {
    /** Create a new GraphTemplate from the nodes and connections inside the graph instance */
    static fromGraph(graph, editor) {
        return new GraphTemplate(graph.save(), editor);
    }
    /** Get the name of the graph template */
    get name() {
        return this._name;
    }
    /** Set the name of the graph template */
    set name(v) {
        this._name = v;
        this.events.nameChanged.emit(v);
        const nt = this.editor.nodeTypes.get(getGraphNodeTypeString(this));
        if (nt) {
            nt.title = v;
        }
    }
    /** List of all inputs to the graph template */
    get inputs() {
        const inputNodes = this.nodes.filter((n) => n.type === GRAPH_INPUT_NODE_TYPE);
        return inputNodes.map((n) => ({
            id: n.graphInterfaceId,
            name: n.inputs.name.value,
            nodeId: n.id,
            nodeInterfaceId: n.outputs.placeholder.id,
        }));
    }
    /** List of all outputs of the graph template */
    get outputs() {
        const outputNodes = this.nodes.filter((n) => n.type === GRAPH_OUTPUT_NODE_TYPE);
        return outputNodes.map((n) => ({
            id: n.graphInterfaceId,
            name: n.inputs.name.value,
            nodeId: n.id,
            nodeInterfaceId: n.outputs.output.id,
        }));
    }
    constructor(state, editor) {
        /** Graph template id */
        this.id = uuidv4();
        this._name = "Subgraph";
        this.events = {
            nameChanged: new BaklavaEvent(this),
            updated: new BaklavaEvent(this),
        };
        this.hooks = {
            beforeLoad: new SequentialHook(this),
            afterSave: new SequentialHook(this),
        };
        this.editor = editor;
        if (state.id) {
            this.id = state.id;
        }
        if (state.name) {
            this._name = state.name;
        }
        this.update(state);
    }
    /** Update the state of the graph template with the provided state */
    update(state) {
        this.nodes = state.nodes;
        this.connections = state.connections;
        this.events.updated.emit();
    }
    save() {
        return {
            id: this.id,
            name: this.name,
            nodes: this.nodes,
            connections: this.connections,
            inputs: this.inputs,
            outputs: this.outputs,
        };
    }
    /**
     * Create a new graph instance from this template
     * or load the state into the provided graph instance.
     */
    createGraph(graph) {
        const idMap = new Map();
        const createNewId = (oldId) => {
            const newId = uuidv4();
            idMap.set(oldId, newId);
            return newId;
        };
        const getNewId = (oldId) => {
            const newId = idMap.get(oldId);
            if (!newId) {
                throw new Error(`Unable to create graph from template: Could not map old id ${oldId} to new id`);
            }
            return newId;
        };
        const mapNodeInterfaceIds = (interfaceStates) => {
            return mapValues(interfaceStates, (intf) => {
                const clonedIntf = {
                    id: createNewId(intf.id),
                    templateId: intf.id,
                    value: intf.value,
                };
                return clonedIntf;
            });
        };
        const nodes = this.nodes.map((n) => ({
            ...n,
            id: createNewId(n.id),
            inputs: mapNodeInterfaceIds(n.inputs),
            outputs: mapNodeInterfaceIds(n.outputs),
        }));
        const connections = this.connections.map((c) => ({
            id: createNewId(c.id),
            from: getNewId(c.from),
            to: getNewId(c.to),
        }));
        const inputs = this.inputs.map((i) => ({
            id: i.id,
            name: i.name,
            nodeId: getNewId(i.nodeId),
            nodeInterfaceId: getNewId(i.nodeInterfaceId),
        }));
        const outputs = this.outputs.map((o) => ({
            id: o.id,
            name: o.name,
            nodeId: getNewId(o.nodeId),
            nodeInterfaceId: getNewId(o.nodeInterfaceId),
        }));
        const clonedState = {
            id: uuidv4(),
            nodes,
            connections,
            inputs,
            outputs,
        };
        if (!graph) {
            graph = new Graph(this.editor);
        }
        const warnings = graph.load(clonedState);
        warnings.forEach((w) => console.warn(w));
        graph.template = this;
        return graph;
    }
}
