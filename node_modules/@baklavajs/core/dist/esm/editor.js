import { PreventableBaklavaEvent, BaklavaEvent, SequentialHook, createProxy, } from "@baklavajs/events";
import { Graph } from "./graph";
import { createGraphNodeType, getGraphNodeTypeString } from "./graphNode";
import { GraphTemplate } from "./graphTemplate";
import { GraphInputNode, GraphOutputNode } from "./graphInterface";
/** The main model class for BaklavaJS */
export class Editor {
    /** List of all registered node types */
    get nodeTypes() {
        return this._nodeTypes;
    }
    /** The root graph */
    get graph() {
        return this._graph;
    }
    /** List of all registered graph templates (subgraphs) */
    get graphTemplates() {
        return this._graphTemplates;
    }
    /** Set of all graphs in the editor, including subgraphs */
    get graphs() {
        return this._graphs;
    }
    /** Whether the editor is currently in the process of loading a saved graph */
    get loading() {
        return this._loading;
    }
    constructor() {
        this.events = {
            loaded: new BaklavaEvent(this),
            beforeRegisterNodeType: new PreventableBaklavaEvent(this),
            registerNodeType: new BaklavaEvent(this),
            beforeUnregisterNodeType: new PreventableBaklavaEvent(this),
            unregisterNodeType: new BaklavaEvent(this),
            beforeAddGraphTemplate: new PreventableBaklavaEvent(this),
            addGraphTemplate: new BaklavaEvent(this),
            beforeRemoveGraphTemplate: new PreventableBaklavaEvent(this),
            removeGraphTemplate: new BaklavaEvent(this),
            registerGraph: new BaklavaEvent(this),
            unregisterGraph: new BaklavaEvent(this),
        };
        this.hooks = {
            save: new SequentialHook(this),
            load: new SequentialHook(this),
        };
        this.graphTemplateEvents = createProxy();
        this.graphTemplateHooks = createProxy();
        this.graphEvents = createProxy();
        this.graphHooks = createProxy();
        this.nodeEvents = createProxy();
        this.nodeHooks = createProxy();
        this.connectionEvents = createProxy();
        this._graphs = new Set();
        this._nodeTypes = new Map();
        this._graph = new Graph(this);
        this._graphTemplates = [];
        this._loading = false;
        this.registerNodeType(GraphInputNode);
        this.registerNodeType(GraphOutputNode);
    }
    /**
     * Register a new node type
     * @param type Actual type / constructor of the node
     * @param options Optionally specify a title and/or a category for this node
     */
    registerNodeType(type, options) {
        var _a, _b;
        if (this.events.beforeRegisterNodeType.emit({ type, options }).prevented) {
            return;
        }
        const nodeInstance = new type();
        this._nodeTypes.set(nodeInstance.type, {
            type,
            category: (_a = options === null || options === void 0 ? void 0 : options.category) !== null && _a !== void 0 ? _a : "default",
            title: (_b = options === null || options === void 0 ? void 0 : options.title) !== null && _b !== void 0 ? _b : nodeInstance.title,
        });
        this.events.registerNodeType.emit({ type, options });
    }
    /**
     * Unregister an existing node type. Will also remove all the nodes of this type in all graphs.
     * @param type String type or node constructor, from which the type will be detected
     */
    unregisterNodeType(type) {
        const stringType = typeof type === "string" ? type : new type().type;
        if (this.nodeTypes.has(stringType)) {
            if (this.events.beforeUnregisterNodeType.emit(stringType).prevented) {
                return;
            }
            this._nodeTypes.delete(stringType);
            this.events.unregisterNodeType.emit(stringType);
        }
    }
    addGraphTemplate(template) {
        if (this.events.beforeAddGraphTemplate.emit(template).prevented) {
            return;
        }
        this._graphTemplates.push(template);
        this.graphTemplateEvents.addTarget(template.events);
        this.graphTemplateHooks.addTarget(template.hooks);
        const nt = createGraphNodeType(template);
        this.registerNodeType(nt, { category: "Subgraphs", title: template.name });
        this.events.addGraphTemplate.emit(template);
    }
    removeGraphTemplate(template) {
        if (this.graphTemplates.includes(template)) {
            if (this.events.beforeRemoveGraphTemplate.emit(template).prevented) {
                return;
            }
            // remove all nodes of this type in all graphs
            const graphNodeType = getGraphNodeTypeString(template);
            for (const g of [this.graph, ...this.graphs.values()]) {
                const nodesToRemove = g.nodes.filter((n) => n.type === graphNodeType);
                for (const n of nodesToRemove) {
                    g.removeNode(n);
                }
            }
            this.unregisterNodeType(graphNodeType);
            this._graphTemplates.splice(this._graphTemplates.indexOf(template), 1);
            this.graphTemplateEvents.removeTarget(template.events);
            this.graphTemplateHooks.removeTarget(template.hooks);
            this.events.removeGraphTemplate.emit(template);
        }
    }
    registerGraph(graph) {
        this.graphEvents.addTarget(graph.events);
        this.graphHooks.addTarget(graph.hooks);
        this.nodeEvents.addTarget(graph.nodeEvents);
        this.nodeHooks.addTarget(graph.nodeHooks);
        this.connectionEvents.addTarget(graph.connectionEvents);
        this.events.registerGraph.emit(graph);
        this._graphs.add(graph);
    }
    unregisterGraph(graph) {
        this.graphEvents.removeTarget(graph.events);
        this.graphHooks.removeTarget(graph.hooks);
        this.nodeEvents.removeTarget(graph.nodeEvents);
        this.nodeHooks.removeTarget(graph.nodeHooks);
        this.connectionEvents.removeTarget(graph.connectionEvents);
        this.events.unregisterGraph.emit(graph);
        this._graphs.delete(graph);
    }
    /**
     * Load a state
     * @param state State to load
     * @returns An array of warnings that occured during loading. If the array is empty, the state was successfully loaded.
     */
    load(state) {
        try {
            this._loading = true;
            state = this.hooks.load.execute(state);
            while (this.graphTemplates.length > 0) {
                this.removeGraphTemplate(this.graphTemplates[0]);
            }
            state.graphTemplates.forEach((tState) => {
                const template = new GraphTemplate(tState, this);
                this.addGraphTemplate(template);
            });
            const warnings = this._graph.load(state.graph);
            this.events.loaded.emit();
            warnings.forEach((w) => console.warn(w));
            return warnings;
        }
        finally {
            this._loading = false;
        }
    }
    /**
     * Save a state
     * @returns Current state
     */
    save() {
        const state = {
            graph: this.graph.save(),
            graphTemplates: this.graphTemplates.map((t) => t.save()),
        };
        return this.hooks.save.execute(state);
    }
}
