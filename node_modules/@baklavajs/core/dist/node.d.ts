import { PreventableBaklavaEvent, BaklavaEvent, SequentialHook, IBaklavaEventEmitter, IBaklavaTapable } from "@baklavajs/events";
import type { INodeUpdateEventData } from "./eventDataTypes";
import type { Graph } from "./graph";
import type { NodeInterfaceDefinition, NodeInterface, NodeInterfaceDefinitionStates } from "./nodeInterface";
import { IEngine } from "./engine";
export interface CalculationContext<G = any, E extends IEngine<G> = IEngine<G>> {
    globalValues: G;
    engine: E;
}
export type CalculateFunctionReturnType<O> = O | Promise<O> | void;
export type CalculateFunction<I, O, C extends CalculationContext = CalculationContext> = (inputs: I, context: C) => CalculateFunctionReturnType<O>;
export interface INodeState<I, O> {
    type: string;
    title: string;
    id: string;
    inputs: NodeInterfaceDefinitionStates<I> & NodeInterfaceDefinitionStates<Record<string, NodeInterface<any>>>;
    outputs: NodeInterfaceDefinitionStates<O> & NodeInterfaceDefinitionStates<Record<string, NodeInterface<any>>>;
}
export declare abstract class AbstractNode implements IBaklavaEventEmitter, IBaklavaTapable {
    protected _title: string;
    /** Type of the node */
    abstract readonly type: string;
    /** Unique identifier of the node */
    id: string;
    abstract inputs: Record<string, NodeInterface<any>>;
    abstract outputs: Record<string, NodeInterface<any>>;
    events: {
        readonly loaded: BaklavaEvent<AbstractNode, AbstractNode>;
        readonly beforeAddInput: PreventableBaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly addInput: BaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly beforeRemoveInput: PreventableBaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly removeInput: BaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly beforeAddOutput: PreventableBaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly addOutput: BaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly beforeRemoveOutput: PreventableBaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly removeOutput: BaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly beforeTitleChanged: PreventableBaklavaEvent<string, AbstractNode>;
        readonly titleChanged: BaklavaEvent<string, AbstractNode>;
        readonly update: BaklavaEvent<INodeUpdateEventData | null, AbstractNode>;
    };
    hooks: {
        readonly beforeLoad: SequentialHook<INodeState<any, any>, AbstractNode, INodeState<any, any>>;
        readonly afterSave: SequentialHook<INodeState<any, any>, AbstractNode, INodeState<any, any>>;
    };
    protected graphInstance?: Graph;
    abstract calculate?: CalculateFunction<any, any>;
    /**
     * The graph instance the node is placed in.
     * `undefined` if the node hasn't been placed in a graph yet.
     */
    get graph(): Graph | undefined;
    /** Customizable display name of the node. */
    get title(): string;
    set title(v: string);
    /**
     * Add an input interface to the node
     * @param key Key of the input
     * @param input The input instance
     * @returns True when the input was added, otherwise false (prevented by an event handler)
     */
    protected addInput(key: string, input: NodeInterface): boolean;
    /**
     * Add an output interface to the node
     * @param key Key of the output
     * @param output The output instance
     * @returns True when the output was added, otherwise false (prevented by an event handler)
     */
    protected addOutput(key: string, output: NodeInterface): boolean;
    /**
     * Remove an existing input
     * @param key Key of the input.
     */
    protected removeInput(key: string): boolean;
    /**
     * Remove an existing output
     * @param key Key of the output.
     */
    protected removeOutput(key: string): boolean;
    /**
     * This function will automatically be called as soon as the node is added to a graph.
     * @param editor Graph instance
     */
    registerGraph(graph: Graph): void;
    load(state: INodeState<any, any>): void;
    save(): INodeState<any, any>;
    /**
     * @virtual
     * Override this method to execute logic when the node is placed inside a graph
     */
    onPlaced(): void;
    /**
     * @virtual
     * Override this method to perform cleanup when the node is deleted
     */
    onDestroy(): void;
    protected initializeIo(): void;
    private initializeIntf;
    private addInterface;
    private removeInterface;
}
/**
 * Abstract base class for every node
 */
export declare abstract class Node<I, O> extends AbstractNode {
    abstract inputs: NodeInterfaceDefinition<I>;
    abstract outputs: NodeInterfaceDefinition<O>;
    load(state: INodeState<I, O>): void;
    save(): INodeState<I, O>;
    /**
     * The default implementation does nothing.
     * Overwrite this method to do calculation.
     * @param inputs Values of all input interfaces
     * @param globalValues Set of values passed to every node by the engine plugin
     * @return Values for output interfaces
     */
    calculate?: CalculateFunction<I, O>;
}
export type AbstractNodeConstructor = new () => AbstractNode;
