import { InterfaceFactory } from "./defineNode";
import { Node, CalculateFunction, INodeState } from "./node";
import { NodeInterface, NodeInterfaceDefinition } from "./nodeInterface";
type Dynamic<T> = T & Record<string, any>;
/**
 * @internal
 * Abstract base class for every dynamic node
 */
export declare abstract class DynamicNode<I, O> extends Node<Dynamic<I>, Dynamic<O>> {
    abstract inputs: NodeInterfaceDefinition<Dynamic<I>>;
    abstract outputs: NodeInterfaceDefinition<Dynamic<O>>;
    abstract load(state: INodeState<Dynamic<I>, Dynamic<O>>): void;
    /**
     * The default implementation does nothing.
     * Overwrite this method to do calculation.
     * @param inputs Values of all input interfaces
     * @param globalValues Set of values passed to every node by the engine plugin
     * @return Values for output interfaces
     */
    calculate?: CalculateFunction<Dynamic<I>, Dynamic<O>>;
}
export type DynamicNodeDefinition = Record<string, (() => NodeInterface<any>) | undefined>;
export interface DynamicNodeUpdateResult {
    inputs?: DynamicNodeDefinition;
    outputs?: DynamicNodeDefinition;
    forceUpdateInputs?: string[];
    forceUpdateOutputs?: string[];
}
export interface IDynamicNodeDefinition<I, O> {
    /** NodeType */
    type: string;
    /** Default title when creating the node. If not specified, it is set to the nodeType */
    title?: string;
    /** Inputs of the node */
    inputs?: InterfaceFactory<I>;
    /** Outputs of the node */
    outputs?: InterfaceFactory<O>;
    /** This function is called whenever the value of one of the static input or output interfaces is changed.
     * It should return a definition for every dynamic interface based on the values of the static interfaces. */
    onUpdate: (inputs: I, outputs: O) => DynamicNodeUpdateResult;
    /** This function is called by the engine with the input values.
     * It should perform the necessary calculation and then return the output values */
    calculate?: CalculateFunction<Dynamic<I>, Dynamic<O>>;
    /** Called as soon as an instance of the node is created but before it is placed into a graph */
    onCreate?: (this: DynamicNode<I, O>) => void;
    /** Called when the node is placed into a graph */
    onPlaced?: (this: DynamicNode<I, O>) => void;
    /** Called after the node is removed from a graph. Can be used for cleanup */
    onDestroy?: (this: DynamicNode<I, O>) => void;
}
export declare function defineDynamicNode<I, O>(definition: IDynamicNodeDefinition<I, O>): new () => DynamicNode<I, O>;
export {};
