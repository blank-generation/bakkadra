import { BaklavaEvent, IBaklavaEventEmitter, IBaklavaTapable, PreventableBaklavaEvent, SequentialHook, ParallelHook } from "@baklavajs/events";
import { Connection, DummyConnection, IConnection, IConnectionState } from "./connection";
import type { Editor } from "./editor";
import { type GraphTemplate } from "./graphTemplate";
import type { IAddConnectionEventData } from "./eventDataTypes";
import type { AbstractNode, INodeState } from "./node";
import type { NodeInterface } from "./nodeInterface";
import { IGraphInterface } from "./graphInterface";
export interface IGraphState {
    id: string;
    nodes: Array<INodeState<unknown, unknown>>;
    connections: IConnectionState[];
    /** @deprecated */
    inputs: Readonly<IGraphInterface[]>;
    /** @deprecated */
    outputs: Readonly<IGraphInterface[]>;
}
export interface CheckConnectionHookResult {
    connectionAllowed: boolean;
    connectionsInDanger: IConnection[];
}
interface PositiveCheckConnectionResult extends CheckConnectionHookResult {
    connectionAllowed: true;
    dummyConnection: DummyConnection;
}
interface NegativeCheckConnectionResult {
    connectionAllowed: false;
}
export type CheckConnectionResult = PositiveCheckConnectionResult | NegativeCheckConnectionResult;
export declare class Graph implements IBaklavaEventEmitter, IBaklavaTapable {
    id: string;
    editor: Editor;
    template?: GraphTemplate;
    activeTransactions: number;
    protected _nodes: AbstractNode[];
    protected _connections: Connection[];
    protected _loading: boolean;
    protected _destroying: boolean;
    events: {
        readonly beforeAddNode: PreventableBaklavaEvent<AbstractNode, Graph>;
        readonly addNode: BaklavaEvent<AbstractNode, Graph>;
        readonly beforeRemoveNode: PreventableBaklavaEvent<AbstractNode, Graph>;
        readonly removeNode: BaklavaEvent<AbstractNode, Graph>;
        readonly beforeAddConnection: PreventableBaklavaEvent<IAddConnectionEventData, Graph>;
        readonly addConnection: BaklavaEvent<IConnection, Graph>;
        readonly checkConnection: PreventableBaklavaEvent<IAddConnectionEventData, Graph>;
        readonly beforeRemoveConnection: PreventableBaklavaEvent<IConnection, Graph>;
        readonly removeConnection: BaklavaEvent<IConnection, Graph>;
    };
    hooks: {
        readonly save: SequentialHook<IGraphState, Graph, IGraphState>;
        readonly load: SequentialHook<IGraphState, Graph, IGraphState>;
        readonly checkConnection: ParallelHook<IAddConnectionEventData, CheckConnectionHookResult, Graph>;
    };
    nodeEvents: {
        readonly loaded: BaklavaEvent<AbstractNode, AbstractNode>;
        readonly beforeAddInput: PreventableBaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly addInput: BaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly beforeRemoveInput: PreventableBaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly removeInput: BaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly beforeAddOutput: PreventableBaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly addOutput: BaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly beforeRemoveOutput: PreventableBaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly removeOutput: BaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly beforeTitleChanged: PreventableBaklavaEvent<string, AbstractNode>;
        readonly titleChanged: BaklavaEvent<string, AbstractNode>;
        readonly update: BaklavaEvent<import("./eventDataTypes").INodeUpdateEventData | null, AbstractNode>;
    } & import("@baklavajs/events").ISubscribableProxy<{
        readonly loaded: BaklavaEvent<AbstractNode, AbstractNode>;
        readonly beforeAddInput: PreventableBaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly addInput: BaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly beforeRemoveInput: PreventableBaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly removeInput: BaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly beforeAddOutput: PreventableBaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly addOutput: BaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly beforeRemoveOutput: PreventableBaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly removeOutput: BaklavaEvent<NodeInterface<any>, AbstractNode>;
        readonly beforeTitleChanged: PreventableBaklavaEvent<string, AbstractNode>;
        readonly titleChanged: BaklavaEvent<string, AbstractNode>;
        readonly update: BaklavaEvent<import("./eventDataTypes").INodeUpdateEventData | null, AbstractNode>;
    }>;
    nodeHooks: {
        readonly beforeLoad: SequentialHook<INodeState<any, any>, AbstractNode, INodeState<any, any>>;
        readonly afterSave: SequentialHook<INodeState<any, any>, AbstractNode, INodeState<any, any>>;
    } & import("@baklavajs/events").ISubscribableProxy<{
        readonly beforeLoad: SequentialHook<INodeState<any, any>, AbstractNode, INodeState<any, any>>;
        readonly afterSave: SequentialHook<INodeState<any, any>, AbstractNode, INodeState<any, any>>;
    }>;
    connectionEvents: {
        readonly destruct: BaklavaEvent<void, Connection>;
    } & import("@baklavajs/events").ISubscribableProxy<{
        readonly destruct: BaklavaEvent<void, Connection>;
    }>;
    /** List of all nodes in this graph */
    get nodes(): ReadonlyArray<AbstractNode>;
    /** List of all connections in this graph */
    get connections(): ReadonlyArray<Connection>;
    /** Whether the graph is currently in the process of loading a saved graph */
    get loading(): boolean;
    /** Whether the graph is currently in the process of destroying itself */
    get destroying(): boolean;
    get inputs(): IGraphInterface[];
    get outputs(): IGraphInterface[];
    constructor(editor: Editor, template?: GraphTemplate);
    /**
     * Add a node to the list of nodes.
     * @param node Instance of a node
     * @returns Instance of the node or undefined if the node was not added
     */
    addNode<T extends AbstractNode>(node: T): T | undefined;
    /**
     * Removes a node from the list.
     * Will also remove all connections from and to the node.
     * @param node Reference to a node in the list.
     */
    removeNode(node: AbstractNode): void;
    /**
     * Add a connection to the list of connections.
     * @param from Start interface for the connection
     * @param to Target interface for the connection
     * @returns The created connection. If no connection could be created, returns `undefined`.
     */
    addConnection(from: NodeInterface<any>, to: NodeInterface<any>): Connection | undefined;
    /**
     * Remove a connection from the list of connections.
     * @param connection Connection instance that should be removed.
     */
    removeConnection(connection: Connection): void;
    /**
     * Checks, whether a connection between two node interfaces would be valid.
     * @param from The starting node interface (must be an output interface)
     * @param to The target node interface (must be an input interface)
     * @returns Whether the connection is allowed or not.
     */
    checkConnection(from: NodeInterface<any>, to: NodeInterface<any>): CheckConnectionResult;
    /**
     * Finds the NodeInterface with the provided id, as long as it exists in this graph
     * @param id id of the NodeInterface to find
     * @returns The NodeInterface if found, otherwise undefined
     */
    findNodeInterface(id: string): NodeInterface<any> | undefined;
    /**
     * Finds the Node with the provided id, as long as it exists in this graph
     * @param id id of the Node to find
     * @returns The Node if found, otherwise undefined
     */
    findNodeById(id: string): AbstractNode | undefined;
    /**
     * Load a state
     * @param state State to load
     * @returns An array of warnings that occured during loading. If the array is empty, the state was successfully loaded.
     */
    load(state: IGraphState): string[];
    /**
     * Save a state
     * @returns Current state
     */
    save(): IGraphState;
    destroy(): void;
    private internalAddConnection;
}
export {};
