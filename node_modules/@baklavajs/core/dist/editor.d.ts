import { PreventableBaklavaEvent, BaklavaEvent, SequentialHook, IBaklavaEventEmitter, IBaklavaTapable } from "@baklavajs/events";
import type { Connection } from "./connection";
import type { IAddNodeTypeEventData, IRegisterNodeTypeOptions } from "./eventDataTypes";
import { Graph, IGraphState } from "./graph";
import { GraphTemplate, IGraphTemplateState } from "./graphTemplate";
import type { AbstractNode, AbstractNodeConstructor } from "./node";
export interface IEditorState extends Record<string, any> {
    graph: IGraphState;
    graphTemplates: IGraphTemplateState[];
}
export interface INodeTypeInformation extends Required<IRegisterNodeTypeOptions> {
    type: AbstractNodeConstructor;
}
/** The main model class for BaklavaJS */
export declare class Editor implements IBaklavaEventEmitter, IBaklavaTapable {
    events: {
        readonly loaded: BaklavaEvent<void, Editor>;
        readonly beforeRegisterNodeType: PreventableBaklavaEvent<IAddNodeTypeEventData, Editor>;
        readonly registerNodeType: BaklavaEvent<IAddNodeTypeEventData, Editor>;
        readonly beforeUnregisterNodeType: PreventableBaklavaEvent<string, Editor>;
        readonly unregisterNodeType: BaklavaEvent<string, Editor>;
        readonly beforeAddGraphTemplate: PreventableBaklavaEvent<GraphTemplate, Editor>;
        readonly addGraphTemplate: BaklavaEvent<GraphTemplate, Editor>;
        readonly beforeRemoveGraphTemplate: PreventableBaklavaEvent<GraphTemplate, Editor>;
        readonly removeGraphTemplate: BaklavaEvent<GraphTemplate, Editor>;
        readonly registerGraph: BaklavaEvent<Graph, Editor>;
        readonly unregisterGraph: BaklavaEvent<Graph, Editor>;
    };
    hooks: {
        readonly save: SequentialHook<IEditorState, Editor, IEditorState>;
        readonly load: SequentialHook<IEditorState, Editor, IEditorState>;
    };
    graphTemplateEvents: {
        readonly nameChanged: BaklavaEvent<string, GraphTemplate>;
        readonly updated: BaklavaEvent<void, GraphTemplate>;
    } & import("@baklavajs/events").ISubscribableProxy<{
        readonly nameChanged: BaklavaEvent<string, GraphTemplate>;
        readonly updated: BaklavaEvent<void, GraphTemplate>;
    }>;
    graphTemplateHooks: {
        readonly beforeLoad: SequentialHook<IGraphTemplateState, GraphTemplate, IGraphTemplateState>;
        readonly afterSave: SequentialHook<IGraphTemplateState, GraphTemplate, IGraphTemplateState>;
    } & import("@baklavajs/events").ISubscribableProxy<{
        readonly beforeLoad: SequentialHook<IGraphTemplateState, GraphTemplate, IGraphTemplateState>;
        readonly afterSave: SequentialHook<IGraphTemplateState, GraphTemplate, IGraphTemplateState>;
    }>;
    graphEvents: {
        readonly beforeAddNode: PreventableBaklavaEvent<AbstractNode, Graph>;
        readonly addNode: BaklavaEvent<AbstractNode, Graph>;
        readonly beforeRemoveNode: PreventableBaklavaEvent<AbstractNode, Graph>;
        readonly removeNode: BaklavaEvent<AbstractNode, Graph>;
        readonly beforeAddConnection: PreventableBaklavaEvent<import("./eventDataTypes").IAddConnectionEventData, Graph>;
        readonly addConnection: BaklavaEvent<import("./connection").IConnection, Graph>;
        readonly checkConnection: PreventableBaklavaEvent<import("./eventDataTypes").IAddConnectionEventData, Graph>;
        readonly beforeRemoveConnection: PreventableBaklavaEvent<import("./connection").IConnection, Graph>;
        readonly removeConnection: BaklavaEvent<import("./connection").IConnection, Graph>;
    } & import("@baklavajs/events").ISubscribableProxy<{
        readonly beforeAddNode: PreventableBaklavaEvent<AbstractNode, Graph>;
        readonly addNode: BaklavaEvent<AbstractNode, Graph>;
        readonly beforeRemoveNode: PreventableBaklavaEvent<AbstractNode, Graph>;
        readonly removeNode: BaklavaEvent<AbstractNode, Graph>;
        readonly beforeAddConnection: PreventableBaklavaEvent<import("./eventDataTypes").IAddConnectionEventData, Graph>;
        readonly addConnection: BaklavaEvent<import("./connection").IConnection, Graph>;
        readonly checkConnection: PreventableBaklavaEvent<import("./eventDataTypes").IAddConnectionEventData, Graph>;
        readonly beforeRemoveConnection: PreventableBaklavaEvent<import("./connection").IConnection, Graph>;
        readonly removeConnection: BaklavaEvent<import("./connection").IConnection, Graph>;
    }>;
    graphHooks: {
        readonly save: SequentialHook<IGraphState, Graph, IGraphState>;
        readonly load: SequentialHook<IGraphState, Graph, IGraphState>;
        readonly checkConnection: import("@baklavajs/events").ParallelHook<import("./eventDataTypes").IAddConnectionEventData, import("./graph").CheckConnectionHookResult, Graph>;
    } & import("@baklavajs/events").ISubscribableProxy<{
        readonly save: SequentialHook<IGraphState, Graph, IGraphState>;
        readonly load: SequentialHook<IGraphState, Graph, IGraphState>;
        readonly checkConnection: import("@baklavajs/events").ParallelHook<import("./eventDataTypes").IAddConnectionEventData, import("./graph").CheckConnectionHookResult, Graph>;
    }>;
    nodeEvents: {
        readonly loaded: BaklavaEvent<AbstractNode, AbstractNode>;
        readonly beforeAddInput: PreventableBaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly addInput: BaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly beforeRemoveInput: PreventableBaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly removeInput: BaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly beforeAddOutput: PreventableBaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly addOutput: BaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly beforeRemoveOutput: PreventableBaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly removeOutput: BaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly beforeTitleChanged: PreventableBaklavaEvent<string, AbstractNode>;
        readonly titleChanged: BaklavaEvent<string, AbstractNode>;
        readonly update: BaklavaEvent<import("./eventDataTypes").INodeUpdateEventData | null, AbstractNode>;
    } & import("@baklavajs/events").ISubscribableProxy<{
        readonly loaded: BaklavaEvent<AbstractNode, AbstractNode>;
        readonly beforeAddInput: PreventableBaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly addInput: BaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly beforeRemoveInput: PreventableBaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly removeInput: BaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly beforeAddOutput: PreventableBaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly addOutput: BaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly beforeRemoveOutput: PreventableBaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly removeOutput: BaklavaEvent<import("./nodeInterface").NodeInterface<any>, AbstractNode>;
        readonly beforeTitleChanged: PreventableBaklavaEvent<string, AbstractNode>;
        readonly titleChanged: BaklavaEvent<string, AbstractNode>;
        readonly update: BaklavaEvent<import("./eventDataTypes").INodeUpdateEventData | null, AbstractNode>;
    }>;
    nodeHooks: {
        readonly beforeLoad: SequentialHook<import("./node").INodeState<any, any>, AbstractNode, import("./node").INodeState<any, any>>;
        readonly afterSave: SequentialHook<import("./node").INodeState<any, any>, AbstractNode, import("./node").INodeState<any, any>>;
    } & import("@baklavajs/events").ISubscribableProxy<{
        readonly beforeLoad: SequentialHook<import("./node").INodeState<any, any>, AbstractNode, import("./node").INodeState<any, any>>;
        readonly afterSave: SequentialHook<import("./node").INodeState<any, any>, AbstractNode, import("./node").INodeState<any, any>>;
    }>;
    connectionEvents: {
        readonly destruct: BaklavaEvent<void, Connection>;
    } & import("@baklavajs/events").ISubscribableProxy<{
        readonly destruct: BaklavaEvent<void, Connection>;
    }>;
    private _graphs;
    private _nodeTypes;
    private _graph;
    private _graphTemplates;
    private _loading;
    /** List of all registered node types */
    get nodeTypes(): ReadonlyMap<string, INodeTypeInformation>;
    /** The root graph */
    get graph(): Graph;
    /** List of all registered graph templates (subgraphs) */
    get graphTemplates(): ReadonlyArray<GraphTemplate>;
    /** Set of all graphs in the editor, including subgraphs */
    get graphs(): ReadonlySet<Graph>;
    /** Whether the editor is currently in the process of loading a saved graph */
    get loading(): boolean;
    constructor();
    /**
     * Register a new node type
     * @param type Actual type / constructor of the node
     * @param options Optionally specify a title and/or a category for this node
     */
    registerNodeType(type: AbstractNodeConstructor, options?: IRegisterNodeTypeOptions): void;
    /**
     * Unregister an existing node type. Will also remove all the nodes of this type in all graphs.
     * @param type String type or node constructor, from which the type will be detected
     */
    unregisterNodeType(type: AbstractNodeConstructor | string): void;
    addGraphTemplate(template: GraphTemplate): void;
    removeGraphTemplate(template: GraphTemplate): void;
    registerGraph(graph: Graph): void;
    unregisterGraph(graph: Graph): void;
    /**
     * Load a state
     * @param state State to load
     * @returns An array of warnings that occured during loading. If the array is empty, the state was successfully loaded.
     */
    load(state: IEditorState): string[];
    /**
     * Save a state
     * @returns Current state
     */
    save(): IEditorState;
}
