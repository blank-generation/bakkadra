import { Node, INodeState, CalculateFunction, AbstractNode } from "./node";
import { NodeInterface } from "./nodeInterface";
export interface IGraphInterface {
    id: string;
    nodeId: string;
    nodeInterfaceId: string;
    name: string;
}
export declare const GRAPH_INPUT_NODE_TYPE = "__baklava_SubgraphInputNode";
export declare const GRAPH_OUTPUT_NODE_TYPE = "__baklava_SubgraphOutputNode";
interface IGraphInterfaceNodeState<I, O> extends INodeState<I, O> {
    graphInterfaceId: string;
}
declare abstract class GraphInterfaceNode<I, O> extends Node<I, O> {
    graphInterfaceId: string;
    constructor();
    onPlaced(): void;
    save(): IGraphInterfaceNodeState<I, O>;
    load(state: IGraphInterfaceNodeState<I, O>): void;
}
export declare class GraphInputNode extends GraphInterfaceNode<{
    name: string;
}, {
    placeholder: any;
}> {
    static isGraphInputNode(v: AbstractNode): v is GraphInputNode;
    readonly type = "__baklava_SubgraphInputNode";
    inputs: {
        name: NodeInterface<string>;
    };
    outputs: {
        placeholder: NodeInterface<undefined>;
    };
}
export type GraphInputNodeState = IGraphInterfaceNodeState<{
    name: string;
}, {
    placeholder: any;
}>;
export declare class GraphOutputNode extends GraphInterfaceNode<{
    name: string;
    placeholder: any;
}, {
    output: any;
}> {
    static isGraphOutputNode(v: AbstractNode): v is GraphOutputNode;
    readonly type = "__baklava_SubgraphOutputNode";
    inputs: {
        name: NodeInterface<string>;
        placeholder: NodeInterface<undefined>;
    };
    outputs: {
        output: NodeInterface<undefined>;
    };
    calculate: CalculateFunction<{
        placeholder: any;
    }, {
        output: any;
    }>;
}
export type GraphOutputNodeState = IGraphInterfaceNodeState<{
    name: string;
    placeholder: any;
}, {
    output: any;
}>;
export {};
