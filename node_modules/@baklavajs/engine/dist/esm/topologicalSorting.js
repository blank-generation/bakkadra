import { Graph } from "@baklavajs/core";
export class CycleError extends Error {
    constructor() {
        super("Cycle detected");
    }
}
function isString(v) {
    return typeof v === "string";
}
export function sortTopologically(nodesOrGraph, pConnections) {
    /** NodeInterface.id -> parent Node.id */
    const interfaceIdToNodeId = new Map();
    /** Node.id -> set of connected node.id */
    const adjacency = new Map();
    const connectionsFromNode = new Map();
    let nodes;
    let connections;
    if (nodesOrGraph instanceof Graph) {
        nodes = nodesOrGraph.nodes;
        connections = nodesOrGraph.connections;
    }
    else {
        if (!pConnections) {
            throw new Error("Invalid argument value: expected array of connections");
        }
        nodes = nodesOrGraph;
        connections = pConnections;
    }
    nodes.forEach((n) => {
        Object.values(n.inputs).forEach((intf) => interfaceIdToNodeId.set(intf.id, n.id));
        Object.values(n.outputs).forEach((intf) => interfaceIdToNodeId.set(intf.id, n.id));
    });
    // build adjacency list
    nodes.forEach((n) => {
        const connectionsFromCurrentNode = connections.filter((c) => c.from && interfaceIdToNodeId.get(c.from.id) === n.id);
        const adjacentNodes = new Set(connectionsFromCurrentNode.map((c) => interfaceIdToNodeId.get(c.to.id)).filter(isString));
        adjacency.set(n.id, adjacentNodes);
        connectionsFromNode.set(n, connectionsFromCurrentNode);
    });
    // startNodes are all nodes that don't have any input connected
    const startNodes = nodes.slice();
    connections.forEach((c) => {
        const index = startNodes.findIndex((n) => interfaceIdToNodeId.get(c.to.id) === n.id);
        if (index >= 0) {
            startNodes.splice(index, 1);
        }
    });
    const sorted = [];
    while (startNodes.length > 0) {
        const n = startNodes.pop();
        sorted.push(n);
        const nodesConnectedFromN = adjacency.get(n.id);
        while (nodesConnectedFromN.size > 0) {
            const mId = nodesConnectedFromN.values().next().value;
            nodesConnectedFromN.delete(mId);
            if (Array.from(adjacency.values()).every((connectedNodes) => !connectedNodes.has(mId))) {
                const m = nodes.find((node) => node.id === mId);
                startNodes.push(m);
            }
        }
    }
    if (Array.from(adjacency.values()).some((c) => c.size > 0)) {
        throw new CycleError();
    }
    return {
        calculationOrder: sorted,
        connectionsFromNode,
        interfaceIdToNodeId,
    };
}
export function containsCycle(nodesOrGraph, connections) {
    try {
        sortTopologically(nodesOrGraph, connections);
        return false;
    }
    catch (err) {
        if (err instanceof CycleError) {
            return true;
        }
        throw err;
    }
}
