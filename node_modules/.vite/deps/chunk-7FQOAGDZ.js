// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version, hash, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if (namespace?.length !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/uuid/dist/esm-browser/v3.js
function v3(value, namespace, buf, offset) {
  return v35(48, md5_default, value, namespace, buf, offset);
}
v3.DNS = DNS;
v3.URL = URL;

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
v5.DNS = DNS;
v5.URL = URL;

// node_modules/@baklavajs/events/dist/esm/subscribable.js
var Subscribable = class {
  constructor() {
    this.listenerMap = /* @__PURE__ */ new Map();
    this._listeners = [];
    this.proxyMap = /* @__PURE__ */ new Map();
    this.proxies = [];
  }
  get listeners() {
    return this._listeners.concat(this.proxies.flatMap((getListeners) => getListeners()));
  }
  /**
   * Subscribe to the event / hook
   * @param token A token that can be used to unsubscribe from the event / hook later on
   * @param callback A callback that will be invoked when the event / hook occurs
   */
  subscribe(token, callback) {
    if (this.listenerMap.has(token)) {
      console.warn("Already subscribed. Unsubscribing for you.\nPlease check that you don't accidentally use the same token twice to register two different handlers for the same event/hook.");
      this.unsubscribe(token);
    }
    this.listenerMap.set(token, callback);
    this._listeners.push(callback);
  }
  /**
   * Remove a listener
   * @param token The token that was specified when subscribing to the listener.
   * An invalid token does not result in an error.
   */
  unsubscribe(token) {
    if (this.listenerMap.has(token)) {
      const callback = this.listenerMap.get(token);
      this.listenerMap.delete(token);
      const i = this._listeners.indexOf(callback);
      if (i >= 0) {
        this._listeners.splice(i, 1);
      }
    }
  }
  /** This function is only used internally for proxies */
  registerProxy(token, getListeners) {
    if (this.proxyMap.has(token)) {
      console.warn("Already subscribed. Unsubscribing for you.\nPlease check that you don't accidentally use the same token twice to register two different proxies for the same event/hook.");
      this.unregisterProxy(token);
    }
    this.proxyMap.set(token, getListeners);
    this.proxies.push(getListeners);
  }
  /** This function is only used internally for proxies */
  unregisterProxy(token) {
    if (!this.proxyMap.has(token)) {
      return;
    }
    const getListeners = this.proxyMap.get(token);
    this.proxyMap.delete(token);
    const i = this.proxies.indexOf(getListeners);
    if (i >= 0) {
      this.proxies.splice(i, 1);
    }
  }
};

// node_modules/@baklavajs/events/dist/esm/event.js
var BaklavaEvent = class extends Subscribable {
  constructor(entity) {
    super();
    this.entity = entity;
  }
  /**
   * Invoke all listeners
   * @param data The data to invoke the listeners with.
   */
  emit(data) {
    this.listeners.forEach((l) => l(data, this.entity));
  }
};
var PreventableBaklavaEvent = class extends Subscribable {
  constructor(entity) {
    super();
    this.entity = entity;
  }
  /**
   * Invoke all listeners.
   * @param data The data to invoke all listeners with
   * @returns An object, where the `prevented` field is `true` when one of the listeners requested to prevent the event, otherwise `false`
   */
  emit(data) {
    let prevented = false;
    const prevent = () => [prevented = true];
    for (const l of Array.from(this.listeners.values())) {
      l(data, prevent, this.entity);
      if (prevented) {
        return { prevented: true };
      }
    }
    return { prevented: false };
  }
};

// node_modules/@baklavajs/events/dist/esm/hook.js
var DynamicSequentialHook = class extends Subscribable {
  execute(data, entity) {
    let currentValue = data;
    for (const callback of this.listeners) {
      currentValue = callback(currentValue, entity);
    }
    return currentValue;
  }
};
var SequentialHook = class extends DynamicSequentialHook {
  constructor(entity) {
    super();
    this.entity = entity;
  }
  execute(data) {
    return super.execute(data, this.entity);
  }
};
var ParallelHook = class extends Subscribable {
  constructor(entity) {
    super();
    this.entity = entity;
  }
  execute(data) {
    const results = [];
    for (const callback of this.listeners) {
      results.push(callback(data, this.entity));
    }
    return results;
  }
};

// node_modules/@baklavajs/events/dist/esm/proxy.js
function createProxy() {
  const token = Symbol();
  const listeners = /* @__PURE__ */ new Map();
  const targets = /* @__PURE__ */ new Set();
  const register = (key, subscribable) => {
    if (subscribable instanceof Subscribable) {
      subscribable.registerProxy(token, () => {
        var _a, _b;
        return (_b = (_a = listeners.get(key)) === null || _a === void 0 ? void 0 : _a.listeners) !== null && _b !== void 0 ? _b : [];
      });
    }
  };
  const addSubscribable = (key) => {
    const subscribable = new Subscribable();
    listeners.set(key, subscribable);
    targets.forEach((t) => register(key, t[key]));
  };
  const addTarget = (target) => {
    targets.add(target);
    for (const key of listeners.keys()) {
      register(key, target[key]);
    }
  };
  const removeTarget = (target) => {
    for (const key of listeners.keys()) {
      if (target[key] instanceof Subscribable) {
        target[key].unregisterProxy(token);
      }
    }
    targets.delete(target);
  };
  const destroy = () => {
    targets.forEach((t) => removeTarget(t));
    listeners.clear();
  };
  return new Proxy({}, {
    get(target, key) {
      if (key === "addTarget") {
        return addTarget;
      } else if (key === "removeTarget") {
        return removeTarget;
      } else if (key === "destroy") {
        return destroy;
      }
      if (typeof key !== "string" || key.startsWith("_")) {
        return target[key];
      }
      if (!listeners.has(key)) {
        addSubscribable(key);
      }
      return listeners.get(key);
    }
  });
}

// node_modules/@baklavajs/core/dist/esm/connection.js
var Connection = class {
  constructor(from, to) {
    this.destructed = false;
    this.events = {
      destruct: new BaklavaEvent(this)
    };
    if (!from || !to) {
      throw new Error("Cannot initialize connection with null/undefined for 'from' or 'to' values");
    }
    this.id = v4_default();
    this.from = from;
    this.to = to;
    this.from.connectionCount++;
    this.to.connectionCount++;
  }
  destruct() {
    this.events.destruct.emit();
    this.from.connectionCount--;
    this.to.connectionCount--;
    this.destructed = true;
  }
};
var DummyConnection = class {
  constructor(from, to) {
    if (!from || !to) {
      throw new Error("Cannot initialize connection with null/undefined for 'from' or 'to' values");
    }
    this.id = v4_default();
    this.from = from;
    this.to = to;
  }
};

// node_modules/@baklavajs/core/dist/esm/utils.js
function mapValues(obj, fn) {
  return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, fn(v)]));
}

// node_modules/@baklavajs/core/dist/esm/node.js
var AbstractNode = class {
  constructor() {
    this._title = "";
    this.id = v4_default();
    this.events = {
      loaded: new BaklavaEvent(this),
      beforeAddInput: new PreventableBaklavaEvent(this),
      addInput: new BaklavaEvent(this),
      beforeRemoveInput: new PreventableBaklavaEvent(this),
      removeInput: new BaklavaEvent(this),
      beforeAddOutput: new PreventableBaklavaEvent(this),
      addOutput: new BaklavaEvent(this),
      beforeRemoveOutput: new PreventableBaklavaEvent(this),
      removeOutput: new BaklavaEvent(this),
      beforeTitleChanged: new PreventableBaklavaEvent(this),
      titleChanged: new BaklavaEvent(this),
      update: new BaklavaEvent(this)
    };
    this.hooks = {
      beforeLoad: new SequentialHook(this),
      afterSave: new SequentialHook(this)
    };
  }
  /**
   * The graph instance the node is placed in.
   * `undefined` if the node hasn't been placed in a graph yet.
   */
  get graph() {
    return this.graphInstance;
  }
  /** Customizable display name of the node. */
  get title() {
    return this._title;
  }
  set title(v) {
    if (!this.events.beforeTitleChanged.emit(v).prevented) {
      this._title = v;
      this.events.titleChanged.emit(v);
    }
  }
  /**
   * Add an input interface to the node
   * @param key Key of the input
   * @param input The input instance
   * @returns True when the input was added, otherwise false (prevented by an event handler)
   */
  addInput(key, input) {
    return this.addInterface("input", key, input);
  }
  /**
   * Add an output interface to the node
   * @param key Key of the output
   * @param output The output instance
   * @returns True when the output was added, otherwise false (prevented by an event handler)
   */
  addOutput(key, output) {
    return this.addInterface("output", key, output);
  }
  /**
   * Remove an existing input
   * @param key Key of the input.
   */
  removeInput(key) {
    return this.removeInterface("input", key);
  }
  /**
   * Remove an existing output
   * @param key Key of the output.
   */
  removeOutput(key) {
    return this.removeInterface("output", key);
  }
  /**
   * This function will automatically be called as soon as the node is added to a graph.
   * @param editor Graph instance
   */
  registerGraph(graph) {
    this.graphInstance = graph;
  }
  load(state) {
    this.hooks.beforeLoad.execute(state);
    this.id = state.id;
    this._title = state.title;
    Object.entries(state.inputs).forEach(([k, v]) => {
      if (this.inputs[k]) {
        this.inputs[k].load(v);
        this.inputs[k].nodeId = this.id;
      }
    });
    Object.entries(state.outputs).forEach(([k, v]) => {
      if (this.outputs[k]) {
        this.outputs[k].load(v);
        this.outputs[k].nodeId = this.id;
      }
    });
    this.events.loaded.emit(this);
  }
  save() {
    const inputStates = mapValues(this.inputs, (intf) => intf.save());
    const outputStates = mapValues(this.outputs, (intf) => intf.save());
    const state = {
      type: this.type,
      id: this.id,
      title: this.title,
      inputs: inputStates,
      outputs: outputStates
    };
    return this.hooks.afterSave.execute(state);
  }
  /**
   * @virtual
   * Override this method to execute logic when the node is placed inside a graph
   */
  onPlaced() {
  }
  /**
   * @virtual
   * Override this method to perform cleanup when the node is deleted
   */
  onDestroy() {
  }
  initializeIo() {
    Object.entries(this.inputs).forEach(([key, intf]) => this.initializeIntf("input", key, intf));
    Object.entries(this.outputs).forEach(([key, intf]) => this.initializeIntf("output", key, intf));
  }
  initializeIntf(type, key, intf) {
    intf.isInput = type === "input";
    intf.nodeId = this.id;
    intf.events.setValue.subscribe(this, () => this.events.update.emit({ type, name: key, intf }));
  }
  addInterface(type, key, intf) {
    const beforeEvent = type === "input" ? this.events.beforeAddInput : this.events.beforeAddOutput;
    const afterEvent = type === "input" ? this.events.addInput : this.events.addOutput;
    const ioObject = type === "input" ? this.inputs : this.outputs;
    if (beforeEvent.emit(intf).prevented) {
      return false;
    }
    ioObject[key] = intf;
    this.initializeIntf(type, key, intf);
    afterEvent.emit(intf);
    return true;
  }
  removeInterface(type, key) {
    const beforeEvent = type === "input" ? this.events.beforeRemoveInput : this.events.beforeRemoveOutput;
    const afterEvent = type === "input" ? this.events.removeInput : this.events.removeOutput;
    const io = type === "input" ? this.inputs[key] : this.outputs[key];
    if (!io || beforeEvent.emit(io).prevented) {
      return false;
    }
    if (io.connectionCount > 0) {
      if (this.graphInstance) {
        const connections = this.graphInstance.connections.filter((c) => c.from === io || c.to === io);
        connections.forEach((c) => {
          this.graphInstance.removeConnection(c);
        });
      } else {
        throw new Error("Interface is connected, but no graph instance is specified. Unable to delete interface");
      }
    }
    io.events.setValue.unsubscribe(this);
    if (type === "input") {
      delete this.inputs[key];
    } else {
      delete this.outputs[key];
    }
    afterEvent.emit(io);
    return true;
  }
};
var Node = class extends AbstractNode {
  load(state) {
    super.load(state);
  }
  save() {
    return super.save();
  }
};

// node_modules/@baklavajs/core/dist/esm/defineNode.js
function defineNode(definition) {
  return class extends Node {
    constructor() {
      var _a, _b;
      super();
      this.type = definition.type;
      this.inputs = {};
      this.outputs = {};
      this.calculate = definition.calculate ? (inputs, globalValues) => {
        return definition.calculate.call(this, inputs, globalValues);
      } : void 0;
      this._title = (_a = definition.title) !== null && _a !== void 0 ? _a : definition.type;
      this.executeFactory("input", definition.inputs);
      this.executeFactory("output", definition.outputs);
      (_b = definition.onCreate) === null || _b === void 0 ? void 0 : _b.call(this);
    }
    onPlaced() {
      var _a;
      (_a = definition.onPlaced) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    onDestroy() {
      var _a;
      (_a = definition.onDestroy) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    executeFactory(type, factory) {
      Object.keys(factory || {}).forEach((k) => {
        const intf = factory[k]();
        if (type === "input") {
          this.addInput(k, intf);
        } else {
          this.addOutput(k, intf);
        }
      });
    }
  };
}

// node_modules/@baklavajs/core/dist/esm/dynamicNode.js
var DynamicNode = class extends Node {
};
function defineDynamicNode(definition) {
  return class extends DynamicNode {
    constructor() {
      var _a, _b, _c, _d;
      super();
      this.type = definition.type;
      this.inputs = {};
      this.outputs = {};
      this.preventUpdate = false;
      this.staticInputKeys = Object.keys((_a = definition.inputs) !== null && _a !== void 0 ? _a : {});
      this.staticOutputKeys = Object.keys((_b = definition.outputs) !== null && _b !== void 0 ? _b : {});
      this._title = (_c = definition.title) !== null && _c !== void 0 ? _c : definition.type;
      this.executeFactory("input", definition.inputs);
      this.executeFactory("output", definition.outputs);
      if (definition.calculate) {
        this.calculate = (inputs, globalValues) => {
          var _a2;
          return (_a2 = definition.calculate) === null || _a2 === void 0 ? void 0 : _a2.call(this, inputs, globalValues);
        };
      }
      (_d = definition.onCreate) === null || _d === void 0 ? void 0 : _d.call(this);
    }
    onPlaced() {
      var _a;
      this.events.update.subscribe(this, (data) => {
        if (!data) {
          return;
        }
        if (data.type === "input" && this.staticInputKeys.includes(data.name) || data.type === "output" && this.staticOutputKeys.includes(data.name)) {
          this.onUpdate();
        }
      });
      this.onUpdate();
      (_a = definition.onPlaced) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    onDestroy() {
      var _a;
      (_a = definition.onDestroy) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    load(state) {
      this.preventUpdate = true;
      this.hooks.beforeLoad.execute(state);
      this.id = state.id;
      this.title = state.title;
      for (const k of this.staticInputKeys) {
        this.inputs[k].load(state.inputs[k]);
        this.inputs[k].nodeId = this.id;
      }
      for (const k of this.staticOutputKeys) {
        this.outputs[k].load(state.outputs[k]);
        this.outputs[k].nodeId = this.id;
      }
      this.preventUpdate = false;
      this.onUpdate();
      this.preventUpdate = true;
      for (const k of Object.keys(state.inputs)) {
        if (!this.staticInputKeys.includes(k)) {
          this.inputs[k].load(state.inputs[k]);
          this.inputs[k].nodeId = this.id;
        }
      }
      for (const k of Object.keys(state.outputs)) {
        if (!this.staticOutputKeys.includes(k)) {
          this.outputs[k].load(state.outputs[k]);
          this.outputs[k].nodeId = this.id;
        }
      }
      this.preventUpdate = false;
      this.events.loaded.emit(this);
    }
    onUpdate() {
      var _a, _b, _c, _d;
      if (this.preventUpdate) {
        return;
      }
      if (this.graph) {
        this.graph.activeTransactions++;
      }
      const inputValues = this.getStaticValues(this.staticInputKeys, this.inputs);
      const outputValues = this.getStaticValues(this.staticOutputKeys, this.outputs);
      const result = definition.onUpdate.call(this, inputValues, outputValues);
      this.updateInterfaces("input", (_a = result.inputs) !== null && _a !== void 0 ? _a : {}, (_b = result.forceUpdateInputs) !== null && _b !== void 0 ? _b : []);
      this.updateInterfaces("output", (_c = result.outputs) !== null && _c !== void 0 ? _c : {}, (_d = result.forceUpdateOutputs) !== null && _d !== void 0 ? _d : []);
      if (this.graph) {
        this.graph.activeTransactions--;
      }
    }
    getStaticValues(keys, interfaces) {
      const values = {};
      for (const k of keys) {
        values[k] = interfaces[k].value;
      }
      return values;
    }
    updateInterfaces(type, newInterfaces, forceUpdates) {
      const staticKeys = type === "input" ? this.staticInputKeys : this.staticOutputKeys;
      const currentInterfaces = type === "input" ? this.inputs : this.outputs;
      for (const k of Object.keys(currentInterfaces)) {
        if (staticKeys.includes(k) || newInterfaces[k] && !forceUpdates.includes(k)) {
          continue;
        }
        if (type === "input") {
          this.removeInput(k);
        } else {
          this.removeOutput(k);
        }
      }
      for (const k of Object.keys(newInterfaces)) {
        if (currentInterfaces[k]) {
          continue;
        }
        const intf = newInterfaces[k]();
        if (type === "input") {
          this.addInput(k, intf);
        } else {
          this.addOutput(k, intf);
        }
      }
    }
    executeFactory(type, factory) {
      Object.keys(factory || {}).forEach((k) => {
        const intf = factory[k]();
        if (type === "input") {
          this.addInput(k, intf);
        } else {
          this.addOutput(k, intf);
        }
      });
    }
  };
}

// node_modules/@baklavajs/core/dist/esm/nodeInterface.js
var NodeInterface = class {
  set connectionCount(v) {
    this._connectionCount = v;
    this.events.setConnectionCount.emit(v);
  }
  get connectionCount() {
    return this._connectionCount;
  }
  set value(v) {
    if (this.events.beforeSetValue.emit(v).prevented) {
      return;
    }
    this._value = v;
    this.events.setValue.emit(v);
  }
  get value() {
    return this._value;
  }
  constructor(name, value) {
    this.id = v4_default();
    this.nodeId = "";
    this.port = true;
    this.hidden = false;
    this.events = {
      setConnectionCount: new BaklavaEvent(this),
      beforeSetValue: new PreventableBaklavaEvent(this),
      setValue: new BaklavaEvent(this),
      updated: new BaklavaEvent(this)
    };
    this.hooks = {
      load: new SequentialHook(this),
      save: new SequentialHook(this)
    };
    this._connectionCount = 0;
    this.name = name;
    this._value = value;
  }
  load(state) {
    this.id = state.id;
    this.templateId = state.templateId;
    this.value = state.value;
    this.hooks.load.execute(state);
  }
  save() {
    const state = {
      id: this.id,
      templateId: this.templateId,
      value: this.value
    };
    return this.hooks.save.execute(state);
  }
  setComponent(value) {
    this.component = value;
    return this;
  }
  setPort(value) {
    this.port = value;
    return this;
  }
  setHidden(value) {
    this.hidden = value;
    return this;
  }
  use(middleware, ...args) {
    middleware(this, ...args);
    return this;
  }
};

// node_modules/@baklavajs/core/dist/esm/graphInterface.js
var GRAPH_INPUT_NODE_TYPE = "__baklava_SubgraphInputNode";
var GRAPH_OUTPUT_NODE_TYPE = "__baklava_SubgraphOutputNode";
var GraphInterfaceNode = class extends Node {
  constructor() {
    super();
    this.graphInterfaceId = v4_default();
  }
  onPlaced() {
    super.onPlaced();
    this.initializeIo();
  }
  save() {
    return {
      ...super.save(),
      graphInterfaceId: this.graphInterfaceId
    };
  }
  load(state) {
    super.load(state);
    this.graphInterfaceId = state.graphInterfaceId;
  }
};
var GraphInputNode = class extends GraphInterfaceNode {
  constructor() {
    super(...arguments);
    this.type = GRAPH_INPUT_NODE_TYPE;
    this.inputs = {
      name: new NodeInterface("Name", "Input")
    };
    this.outputs = {
      placeholder: new NodeInterface("Value", void 0)
    };
  }
  static isGraphInputNode(v) {
    return v.type === GRAPH_INPUT_NODE_TYPE;
  }
};
var GraphOutputNode = class extends GraphInterfaceNode {
  constructor() {
    super(...arguments);
    this.type = GRAPH_OUTPUT_NODE_TYPE;
    this.inputs = {
      name: new NodeInterface("Name", "Output"),
      placeholder: new NodeInterface("Value", void 0)
    };
    this.outputs = {
      output: new NodeInterface("Output", void 0).setHidden(true)
    };
    this.calculate = ({ placeholder }) => ({
      output: placeholder
    });
  }
  static isGraphOutputNode(v) {
    return v.type === GRAPH_OUTPUT_NODE_TYPE;
  }
};

// node_modules/@baklavajs/core/dist/esm/graph.js
var Graph = class {
  /** List of all nodes in this graph */
  get nodes() {
    return this._nodes;
  }
  /** List of all connections in this graph */
  get connections() {
    return this._connections;
  }
  /** Whether the graph is currently in the process of loading a saved graph */
  get loading() {
    return this._loading;
  }
  /** Whether the graph is currently in the process of destroying itself */
  get destroying() {
    return this._destroying;
  }
  get inputs() {
    const inputNodes = this.nodes.filter((n) => n.type === GRAPH_INPUT_NODE_TYPE);
    return inputNodes.map((n) => ({
      id: n.graphInterfaceId,
      name: n.inputs.name.value,
      nodeId: n.id,
      nodeInterfaceId: n.outputs.placeholder.id
    }));
  }
  get outputs() {
    const outputNodes = this.nodes.filter((n) => n.type === GRAPH_OUTPUT_NODE_TYPE);
    return outputNodes.map((n) => ({
      id: n.graphInterfaceId,
      name: n.inputs.name.value,
      nodeId: n.id,
      nodeInterfaceId: n.outputs.output.id
    }));
  }
  constructor(editor, template) {
    this.id = v4_default();
    this.activeTransactions = 0;
    this._nodes = [];
    this._connections = [];
    this._loading = false;
    this._destroying = false;
    this.events = {
      beforeAddNode: new PreventableBaklavaEvent(this),
      addNode: new BaklavaEvent(this),
      beforeRemoveNode: new PreventableBaklavaEvent(this),
      removeNode: new BaklavaEvent(this),
      beforeAddConnection: new PreventableBaklavaEvent(this),
      addConnection: new BaklavaEvent(this),
      checkConnection: new PreventableBaklavaEvent(this),
      beforeRemoveConnection: new PreventableBaklavaEvent(this),
      removeConnection: new BaklavaEvent(this)
    };
    this.hooks = {
      save: new SequentialHook(this),
      load: new SequentialHook(this),
      checkConnection: new ParallelHook(this)
    };
    this.nodeEvents = createProxy();
    this.nodeHooks = createProxy();
    this.connectionEvents = createProxy();
    this.editor = editor;
    this.template = template;
    editor.registerGraph(this);
  }
  /**
   * Add a node to the list of nodes.
   * @param node Instance of a node
   * @returns Instance of the node or undefined if the node was not added
   */
  addNode(node) {
    if (this.events.beforeAddNode.emit(node).prevented) {
      return;
    }
    this.nodeEvents.addTarget(node.events);
    this.nodeHooks.addTarget(node.hooks);
    node.registerGraph(this);
    this._nodes.push(node);
    node = this.nodes.find((n) => n.id === node.id);
    node.onPlaced();
    this.events.addNode.emit(node);
    return node;
  }
  /**
   * Removes a node from the list.
   * Will also remove all connections from and to the node.
   * @param node Reference to a node in the list.
   */
  removeNode(node) {
    if (this.nodes.includes(node)) {
      if (this.events.beforeRemoveNode.emit(node).prevented) {
        return;
      }
      const interfaces = [...Object.values(node.inputs), ...Object.values(node.outputs)];
      this.connections.filter((c) => interfaces.includes(c.from) || interfaces.includes(c.to)).forEach((c) => this.removeConnection(c));
      this._nodes.splice(this.nodes.indexOf(node), 1);
      this.events.removeNode.emit(node);
      node.onDestroy();
      this.nodeEvents.removeTarget(node.events);
      this.nodeHooks.removeTarget(node.hooks);
    }
  }
  /**
   * Add a connection to the list of connections.
   * @param from Start interface for the connection
   * @param to Target interface for the connection
   * @returns The created connection. If no connection could be created, returns `undefined`.
   */
  addConnection(from, to) {
    const checkConnectionResult = this.checkConnection(from, to);
    if (!checkConnectionResult.connectionAllowed) {
      return void 0;
    }
    if (this.events.beforeAddConnection.emit({ from, to }).prevented) {
      return;
    }
    for (const connectionToRemove of checkConnectionResult.connectionsInDanger) {
      const instance = this.connections.find((c2) => c2.id === connectionToRemove.id);
      if (instance) {
        this.removeConnection(instance);
      }
    }
    const c = new Connection(checkConnectionResult.dummyConnection.from, checkConnectionResult.dummyConnection.to);
    this.internalAddConnection(c);
    return c;
  }
  /**
   * Remove a connection from the list of connections.
   * @param connection Connection instance that should be removed.
   */
  removeConnection(connection) {
    if (this.connections.includes(connection)) {
      if (this.events.beforeRemoveConnection.emit(connection).prevented) {
        return;
      }
      connection.destruct();
      this._connections.splice(this.connections.indexOf(connection), 1);
      this.events.removeConnection.emit(connection);
      this.connectionEvents.removeTarget(connection.events);
    }
  }
  /**
   * Checks, whether a connection between two node interfaces would be valid.
   * @param from The starting node interface (must be an output interface)
   * @param to The target node interface (must be an input interface)
   * @returns Whether the connection is allowed or not.
   */
  checkConnection(from, to) {
    if (!from || !to) {
      return { connectionAllowed: false };
    }
    const fromNode = this.findNodeById(from.nodeId);
    const toNode = this.findNodeById(to.nodeId);
    if (fromNode && toNode && fromNode === toNode) {
      return { connectionAllowed: false };
    }
    if (from.isInput && !to.isInput) {
      const tmp = from;
      from = to;
      to = tmp;
    }
    if (from.isInput || !to.isInput) {
      return { connectionAllowed: false };
    }
    if (this.connections.some((c) => c.from === from && c.to === to)) {
      return { connectionAllowed: false };
    }
    if (this.events.checkConnection.emit({ from, to }).prevented) {
      return { connectionAllowed: false };
    }
    const hookResults = this.hooks.checkConnection.execute({ from, to });
    if (hookResults.some((hr) => !hr.connectionAllowed)) {
      return { connectionAllowed: false };
    }
    const connectionsInDanger = Array.from(new Set(hookResults.flatMap((hr) => hr.connectionsInDanger)));
    return {
      connectionAllowed: true,
      dummyConnection: new DummyConnection(from, to),
      connectionsInDanger
    };
  }
  /**
   * Finds the NodeInterface with the provided id, as long as it exists in this graph
   * @param id id of the NodeInterface to find
   * @returns The NodeInterface if found, otherwise undefined
   */
  findNodeInterface(id) {
    for (const node of this.nodes) {
      for (const k in node.inputs) {
        const nodeInput = node.inputs[k];
        if (nodeInput.id === id) {
          return nodeInput;
        }
      }
      for (const k in node.outputs) {
        const nodeOutput = node.outputs[k];
        if (nodeOutput.id === id) {
          return nodeOutput;
        }
      }
    }
  }
  /**
   * Finds the Node with the provided id, as long as it exists in this graph
   * @param id id of the Node to find
   * @returns The Node if found, otherwise undefined
   */
  findNodeById(id) {
    return this.nodes.find((n) => n.id === id);
  }
  /**
   * Load a state
   * @param state State to load
   * @returns An array of warnings that occured during loading. If the array is empty, the state was successfully loaded.
   */
  load(state) {
    try {
      this._loading = true;
      const warnings = [];
      for (let i = this.connections.length - 1; i >= 0; i--) {
        this.removeConnection(this.connections[i]);
      }
      for (let i = this.nodes.length - 1; i >= 0; i--) {
        this.removeNode(this.nodes[i]);
      }
      this.id = state.id;
      for (const n of state.nodes) {
        const nodeInformation = this.editor.nodeTypes.get(n.type);
        if (!nodeInformation) {
          warnings.push(`Node type ${n.type} is not registered`);
          continue;
        }
        const node = new nodeInformation.type();
        this.addNode(node);
        node.load(n);
      }
      for (const c of state.connections) {
        const fromIf = this.findNodeInterface(c.from);
        const toIf = this.findNodeInterface(c.to);
        if (!fromIf) {
          warnings.push(`Could not find interface with id ${c.from}`);
          continue;
        } else if (!toIf) {
          warnings.push(`Could not find interface with id ${c.to}`);
          continue;
        } else {
          const conn = new Connection(fromIf, toIf);
          conn.id = c.id;
          this.internalAddConnection(conn);
        }
      }
      this.hooks.load.execute(state);
      return warnings;
    } finally {
      this._loading = false;
    }
  }
  /**
   * Save a state
   * @returns Current state
   */
  save() {
    const state = {
      id: this.id,
      nodes: this.nodes.map((n) => n.save()),
      connections: this.connections.map((c) => ({
        id: c.id,
        from: c.from.id,
        to: c.to.id
      })),
      inputs: this.inputs,
      outputs: this.outputs
    };
    return this.hooks.save.execute(state);
  }
  destroy() {
    this._destroying = true;
    for (const n of this.nodes) {
      this.removeNode(n);
    }
    this.editor.unregisterGraph(this);
  }
  internalAddConnection(c) {
    this.connectionEvents.addTarget(c.events);
    this._connections.push(c);
    this.events.addConnection.emit(c);
  }
};

// node_modules/@baklavajs/core/dist/esm/graphNode.js
var GRAPH_NODE_TYPE_PREFIX = "__baklava_GraphNode-";
function getGraphNodeTypeString(template) {
  return GRAPH_NODE_TYPE_PREFIX + template.id;
}
var PROXY_INTERFACE_SKIP_PROPERTIES = [
  "component",
  "connectionCount",
  "events",
  "hidden",
  "hooks",
  "id",
  "isInput",
  "name",
  "nodeId",
  "port",
  "templateId",
  "value"
];
function createGraphNodeType(template) {
  return class GraphNode extends AbstractNode {
    constructor() {
      super(...arguments);
      this.type = getGraphNodeTypeString(template);
      this.inputs = {};
      this.outputs = {};
      this.template = template;
      this.calculate = async (inputs, context) => {
        var _a;
        if (!this.subgraph) {
          throw new Error(`GraphNode ${this.id}: calculate called without subgraph being initialized`);
        }
        if (!context.engine || typeof context.engine !== "object") {
          throw new Error(`GraphNode ${this.id}: calculate called but no engine provided in context`);
        }
        const graphInputs = context.engine.getInputValues(this.subgraph);
        for (const input of this.subgraph.inputs) {
          graphInputs.set(input.nodeInterfaceId, inputs[input.id]);
        }
        const result = await context.engine.runGraph(this.subgraph, graphInputs, context.globalValues);
        const outputs = {};
        for (const output of this.subgraph.outputs) {
          outputs[output.id] = (_a = result.get(output.nodeId)) === null || _a === void 0 ? void 0 : _a.get("output");
        }
        outputs._calculationResults = result;
        return outputs;
      };
    }
    get title() {
      return this._title;
    }
    set title(v) {
      this.template.name = v;
    }
    load(state) {
      if (!this.subgraph) {
        throw new Error("Cannot load a graph node without a graph");
      }
      if (!this.template) {
        throw new Error("Unable to load graph node without graph template");
      }
      this.subgraph.load(state.graphState);
      super.load(state);
    }
    save() {
      if (!this.subgraph) {
        throw new Error("Cannot save a graph node without a graph");
      }
      const state = super.save();
      return {
        ...state,
        graphState: this.subgraph.save()
      };
    }
    onPlaced() {
      this.template.events.updated.subscribe(this, () => this.initialize());
      this.template.events.nameChanged.subscribe(this, (name) => {
        this._title = name;
      });
      this.initialize();
    }
    onDestroy() {
      var _a;
      this.template.events.updated.unsubscribe(this);
      this.template.events.nameChanged.unsubscribe(this);
      (_a = this.subgraph) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    initialize() {
      if (this.subgraph) {
        this.subgraph.destroy();
      }
      this.subgraph = this.template.createGraph();
      this._title = this.template.name;
      this.updateInterfaces();
      this.events.update.emit(null);
    }
    updateInterfaces() {
      if (!this.subgraph) {
        throw new Error("Trying to update interfaces without graph instance");
      }
      for (const graphInput of this.subgraph.inputs) {
        if (!(graphInput.id in this.inputs)) {
          this.addInput(graphInput.id, this.createProxyInterface(graphInput, true));
        } else {
          this.inputs[graphInput.id].name = graphInput.name;
        }
      }
      for (const k of Object.keys(this.inputs)) {
        if (!this.subgraph.inputs.some((gi) => gi.id === k)) {
          this.removeInput(k);
        }
      }
      for (const graphOutput of this.subgraph.outputs) {
        if (!(graphOutput.id in this.outputs)) {
          this.addOutput(graphOutput.id, this.createProxyInterface(graphOutput, false));
        } else {
          this.outputs[graphOutput.id].name = graphOutput.name;
        }
      }
      for (const k of Object.keys(this.outputs)) {
        if (!this.subgraph.outputs.some((gi) => gi.id === k)) {
          this.removeOutput(k);
        }
      }
      this.addOutput("_calculationResults", new NodeInterface("_calculationResults", void 0).setHidden(true));
    }
    /**
     * When we create a interface in the graph node, we hide certain properties of the interface in the subgraph.
     * For example, the `type` property or the `allowMultipleConnections` property.
     * These properties should be proxied to the subgraph interface, so they behave the same as the original interface.
     */
    createProxyInterface(graphInterface, isInput) {
      const newInterface = new NodeInterface(graphInterface.name, void 0);
      return new Proxy(newInterface, {
        get: (target, prop) => {
          var _a, _b, _c;
          if (PROXY_INTERFACE_SKIP_PROPERTIES.includes(prop) || prop in target || typeof prop === "string" && prop.startsWith("__v_")) {
            return Reflect.get(target, prop);
          }
          let placeholderIntfId;
          if (isInput) {
            const subgraphInterfaceNode = (_a = this.subgraph) === null || _a === void 0 ? void 0 : _a.nodes.find((n) => GraphInputNode.isGraphInputNode(n) && n.graphInterfaceId === graphInterface.id);
            placeholderIntfId = subgraphInterfaceNode === null || subgraphInterfaceNode === void 0 ? void 0 : subgraphInterfaceNode.outputs.placeholder.id;
          } else {
            const subgraphInterfaceNode = (_b = this.subgraph) === null || _b === void 0 ? void 0 : _b.nodes.find((n) => GraphOutputNode.isGraphOutputNode(n) && n.graphInterfaceId === graphInterface.id);
            placeholderIntfId = subgraphInterfaceNode === null || subgraphInterfaceNode === void 0 ? void 0 : subgraphInterfaceNode.inputs.placeholder.id;
          }
          const conn = (_c = this.subgraph) === null || _c === void 0 ? void 0 : _c.connections.find((c) => {
            var _a2;
            return placeholderIntfId === ((_a2 = isInput ? c.from : c.to) === null || _a2 === void 0 ? void 0 : _a2.id);
          });
          const intf = isInput ? conn === null || conn === void 0 ? void 0 : conn.to : conn === null || conn === void 0 ? void 0 : conn.from;
          if (intf) {
            return Reflect.get(intf, prop);
          }
          return void 0;
        }
      });
    }
  };
}

// node_modules/@baklavajs/core/dist/esm/graphTemplate.js
var GraphTemplate = class _GraphTemplate {
  /** Create a new GraphTemplate from the nodes and connections inside the graph instance */
  static fromGraph(graph, editor) {
    return new _GraphTemplate(graph.save(), editor);
  }
  /** Get the name of the graph template */
  get name() {
    return this._name;
  }
  /** Set the name of the graph template */
  set name(v) {
    this._name = v;
    this.events.nameChanged.emit(v);
    const nt = this.editor.nodeTypes.get(getGraphNodeTypeString(this));
    if (nt) {
      nt.title = v;
    }
  }
  /** List of all inputs to the graph template */
  get inputs() {
    const inputNodes = this.nodes.filter((n) => n.type === GRAPH_INPUT_NODE_TYPE);
    return inputNodes.map((n) => ({
      id: n.graphInterfaceId,
      name: n.inputs.name.value,
      nodeId: n.id,
      nodeInterfaceId: n.outputs.placeholder.id
    }));
  }
  /** List of all outputs of the graph template */
  get outputs() {
    const outputNodes = this.nodes.filter((n) => n.type === GRAPH_OUTPUT_NODE_TYPE);
    return outputNodes.map((n) => ({
      id: n.graphInterfaceId,
      name: n.inputs.name.value,
      nodeId: n.id,
      nodeInterfaceId: n.outputs.output.id
    }));
  }
  constructor(state, editor) {
    this.id = v4_default();
    this._name = "Subgraph";
    this.events = {
      nameChanged: new BaklavaEvent(this),
      updated: new BaklavaEvent(this)
    };
    this.hooks = {
      beforeLoad: new SequentialHook(this),
      afterSave: new SequentialHook(this)
    };
    this.editor = editor;
    if (state.id) {
      this.id = state.id;
    }
    if (state.name) {
      this._name = state.name;
    }
    this.update(state);
  }
  /** Update the state of the graph template with the provided state */
  update(state) {
    this.nodes = state.nodes;
    this.connections = state.connections;
    this.events.updated.emit();
  }
  save() {
    return {
      id: this.id,
      name: this.name,
      nodes: this.nodes,
      connections: this.connections,
      inputs: this.inputs,
      outputs: this.outputs
    };
  }
  /**
   * Create a new graph instance from this template
   * or load the state into the provided graph instance.
   */
  createGraph(graph) {
    const idMap = /* @__PURE__ */ new Map();
    const createNewId = (oldId) => {
      const newId = v4_default();
      idMap.set(oldId, newId);
      return newId;
    };
    const getNewId = (oldId) => {
      const newId = idMap.get(oldId);
      if (!newId) {
        throw new Error(`Unable to create graph from template: Could not map old id ${oldId} to new id`);
      }
      return newId;
    };
    const mapNodeInterfaceIds = (interfaceStates) => {
      return mapValues(interfaceStates, (intf) => {
        const clonedIntf = {
          id: createNewId(intf.id),
          templateId: intf.id,
          value: intf.value
        };
        return clonedIntf;
      });
    };
    const nodes = this.nodes.map((n) => ({
      ...n,
      id: createNewId(n.id),
      inputs: mapNodeInterfaceIds(n.inputs),
      outputs: mapNodeInterfaceIds(n.outputs)
    }));
    const connections = this.connections.map((c) => ({
      id: createNewId(c.id),
      from: getNewId(c.from),
      to: getNewId(c.to)
    }));
    const inputs = this.inputs.map((i) => ({
      id: i.id,
      name: i.name,
      nodeId: getNewId(i.nodeId),
      nodeInterfaceId: getNewId(i.nodeInterfaceId)
    }));
    const outputs = this.outputs.map((o) => ({
      id: o.id,
      name: o.name,
      nodeId: getNewId(o.nodeId),
      nodeInterfaceId: getNewId(o.nodeInterfaceId)
    }));
    const clonedState = {
      id: v4_default(),
      nodes,
      connections,
      inputs,
      outputs
    };
    if (!graph) {
      graph = new Graph(this.editor);
    }
    const warnings = graph.load(clonedState);
    warnings.forEach((w) => console.warn(w));
    graph.template = this;
    return graph;
  }
};

// node_modules/@baklavajs/core/dist/esm/editor.js
var Editor = class {
  /** List of all registered node types */
  get nodeTypes() {
    return this._nodeTypes;
  }
  /** The root graph */
  get graph() {
    return this._graph;
  }
  /** List of all registered graph templates (subgraphs) */
  get graphTemplates() {
    return this._graphTemplates;
  }
  /** Set of all graphs in the editor, including subgraphs */
  get graphs() {
    return this._graphs;
  }
  /** Whether the editor is currently in the process of loading a saved graph */
  get loading() {
    return this._loading;
  }
  constructor() {
    this.events = {
      loaded: new BaklavaEvent(this),
      beforeRegisterNodeType: new PreventableBaklavaEvent(this),
      registerNodeType: new BaklavaEvent(this),
      beforeUnregisterNodeType: new PreventableBaklavaEvent(this),
      unregisterNodeType: new BaklavaEvent(this),
      beforeAddGraphTemplate: new PreventableBaklavaEvent(this),
      addGraphTemplate: new BaklavaEvent(this),
      beforeRemoveGraphTemplate: new PreventableBaklavaEvent(this),
      removeGraphTemplate: new BaklavaEvent(this),
      registerGraph: new BaklavaEvent(this),
      unregisterGraph: new BaklavaEvent(this)
    };
    this.hooks = {
      save: new SequentialHook(this),
      load: new SequentialHook(this)
    };
    this.graphTemplateEvents = createProxy();
    this.graphTemplateHooks = createProxy();
    this.graphEvents = createProxy();
    this.graphHooks = createProxy();
    this.nodeEvents = createProxy();
    this.nodeHooks = createProxy();
    this.connectionEvents = createProxy();
    this._graphs = /* @__PURE__ */ new Set();
    this._nodeTypes = /* @__PURE__ */ new Map();
    this._graph = new Graph(this);
    this._graphTemplates = [];
    this._loading = false;
    this.registerNodeType(GraphInputNode);
    this.registerNodeType(GraphOutputNode);
  }
  /**
   * Register a new node type
   * @param type Actual type / constructor of the node
   * @param options Optionally specify a title and/or a category for this node
   */
  registerNodeType(type, options) {
    var _a, _b;
    if (this.events.beforeRegisterNodeType.emit({ type, options }).prevented) {
      return;
    }
    const nodeInstance = new type();
    this._nodeTypes.set(nodeInstance.type, {
      type,
      category: (_a = options === null || options === void 0 ? void 0 : options.category) !== null && _a !== void 0 ? _a : "default",
      title: (_b = options === null || options === void 0 ? void 0 : options.title) !== null && _b !== void 0 ? _b : nodeInstance.title
    });
    this.events.registerNodeType.emit({ type, options });
  }
  /**
   * Unregister an existing node type. Will also remove all the nodes of this type in all graphs.
   * @param type String type or node constructor, from which the type will be detected
   */
  unregisterNodeType(type) {
    const stringType = typeof type === "string" ? type : new type().type;
    if (this.nodeTypes.has(stringType)) {
      if (this.events.beforeUnregisterNodeType.emit(stringType).prevented) {
        return;
      }
      this._nodeTypes.delete(stringType);
      this.events.unregisterNodeType.emit(stringType);
    }
  }
  addGraphTemplate(template) {
    if (this.events.beforeAddGraphTemplate.emit(template).prevented) {
      return;
    }
    this._graphTemplates.push(template);
    this.graphTemplateEvents.addTarget(template.events);
    this.graphTemplateHooks.addTarget(template.hooks);
    const nt = createGraphNodeType(template);
    this.registerNodeType(nt, { category: "Subgraphs", title: template.name });
    this.events.addGraphTemplate.emit(template);
  }
  removeGraphTemplate(template) {
    if (this.graphTemplates.includes(template)) {
      if (this.events.beforeRemoveGraphTemplate.emit(template).prevented) {
        return;
      }
      const graphNodeType = getGraphNodeTypeString(template);
      for (const g of [this.graph, ...this.graphs.values()]) {
        const nodesToRemove = g.nodes.filter((n) => n.type === graphNodeType);
        for (const n of nodesToRemove) {
          g.removeNode(n);
        }
      }
      this.unregisterNodeType(graphNodeType);
      this._graphTemplates.splice(this._graphTemplates.indexOf(template), 1);
      this.graphTemplateEvents.removeTarget(template.events);
      this.graphTemplateHooks.removeTarget(template.hooks);
      this.events.removeGraphTemplate.emit(template);
    }
  }
  registerGraph(graph) {
    this.graphEvents.addTarget(graph.events);
    this.graphHooks.addTarget(graph.hooks);
    this.nodeEvents.addTarget(graph.nodeEvents);
    this.nodeHooks.addTarget(graph.nodeHooks);
    this.connectionEvents.addTarget(graph.connectionEvents);
    this.events.registerGraph.emit(graph);
    this._graphs.add(graph);
  }
  unregisterGraph(graph) {
    this.graphEvents.removeTarget(graph.events);
    this.graphHooks.removeTarget(graph.hooks);
    this.nodeEvents.removeTarget(graph.nodeEvents);
    this.nodeHooks.removeTarget(graph.nodeHooks);
    this.connectionEvents.removeTarget(graph.connectionEvents);
    this.events.unregisterGraph.emit(graph);
    this._graphs.delete(graph);
  }
  /**
   * Load a state
   * @param state State to load
   * @returns An array of warnings that occured during loading. If the array is empty, the state was successfully loaded.
   */
  load(state) {
    try {
      this._loading = true;
      state = this.hooks.load.execute(state);
      while (this.graphTemplates.length > 0) {
        this.removeGraphTemplate(this.graphTemplates[0]);
      }
      state.graphTemplates.forEach((tState) => {
        const template = new GraphTemplate(tState, this);
        this.addGraphTemplate(template);
      });
      const warnings = this._graph.load(state.graph);
      this.events.loaded.emit();
      warnings.forEach((w) => console.warn(w));
      return warnings;
    } finally {
      this._loading = false;
    }
  }
  /**
   * Save a state
   * @returns Current state
   */
  save() {
    const state = {
      graph: this.graph.save(),
      graphTemplates: this.graphTemplates.map((t) => t.save())
    };
    return this.hooks.save.execute(state);
  }
};

export {
  BaklavaEvent,
  PreventableBaklavaEvent,
  DynamicSequentialHook,
  SequentialHook,
  Connection,
  DummyConnection,
  AbstractNode,
  Node,
  defineNode,
  DynamicNode,
  defineDynamicNode,
  NodeInterface,
  GRAPH_INPUT_NODE_TYPE,
  GRAPH_OUTPUT_NODE_TYPE,
  GraphInputNode,
  GraphOutputNode,
  Graph,
  GRAPH_NODE_TYPE_PREFIX,
  getGraphNodeTypeString,
  createGraphNodeType,
  GraphTemplate,
  Editor
};
//# sourceMappingURL=chunk-7FQOAGDZ.js.map
