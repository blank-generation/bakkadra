{
  "version": 3,
  "sources": ["../../@baklavajs/interface-types/dist/esm/index.js"],
  "sourcesContent": ["/**\n * @module @baklavajs/interface-types\n */\nexport class NodeInterfaceType {\n    constructor(name) {\n        this.name = name;\n        this.conversions = [];\n    }\n    /**\n     * A conversion makes it possible to connect two node interfaces although they have different types.\n     * @param to Type to convert to\n     * @param transformationFunction\n     * Will be called to transform the value from one type to another.\n     * A transformation to convert the type `string` to `number` could be `parseInt`.\n     *\n     * @returns the instance the method was called on for chaining\n     */\n    addConversion(to, transformationFunction = (value) => value) {\n        this.conversions.push({\n            targetType: to.name,\n            transformationFunction,\n        });\n        return this;\n    }\n}\nexport function setType(intf, type) {\n    intf.type = type.name;\n}\n/** Use this function to set the type for a NodeInterface with `allowMultipleConnections` */\nexport function setTypeForMultipleConnections(intf, type) {\n    intf.type = type.name;\n}\nexport function getType(intf) {\n    return intf.type;\n}\nexport class BaklavaInterfaceTypes {\n    constructor(editor, options) {\n        this.types = new Map();\n        this.editor = editor;\n        this.editor.graphEvents.checkConnection.subscribe(this, ({ from, to }, prevent) => {\n            const fromType = from.type;\n            const toType = to.type;\n            if (!fromType || !toType) {\n                return;\n            }\n            else if (!this.canConvert(fromType, toType)) {\n                return prevent();\n            }\n        });\n        if (options === null || options === void 0 ? void 0 : options.engine) {\n            options.engine.hooks.transferData.subscribe(this, (value, connection) => {\n                const fromType = connection.from.type;\n                const toType = connection.to.type;\n                if (!fromType || !toType) {\n                    return value;\n                }\n                return this.convert(fromType, toType, value);\n            });\n        }\n        if (options === null || options === void 0 ? void 0 : options.viewPlugin) {\n            options.viewPlugin.hooks.renderInterface.subscribe(this, ({ intf, el }) => {\n                if (intf.type) {\n                    el.setAttribute(\"data-interface-type\", intf.type);\n                }\n                return { intf, el };\n            });\n        }\n    }\n    /**\n     * Add a new node interface type\n     * @param types The types to add\n     */\n    addTypes(...types) {\n        types.forEach((t) => {\n            this.types.set(t.name, t);\n        });\n        return this;\n    }\n    getConversion(from, to) {\n        var _a, _b;\n        return (_b = (_a = this.types.get(from)) === null || _a === void 0 ? void 0 : _a.conversions.find((c) => c.targetType === to)) !== null && _b !== void 0 ? _b : null;\n    }\n    canConvert(from, to) {\n        return (from === to || (this.types.has(from) && this.types.get(from).conversions.some((c) => c.targetType === to)));\n    }\n    convert(from, to, value) {\n        if (from === to) {\n            return value;\n        }\n        else {\n            const c = this.getConversion(from, to);\n            if (c) {\n                return c.transformationFunction(value);\n            }\n            else {\n                throw Error(`Can not convert from \"${from}\" to \"${to}\"`);\n            }\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
