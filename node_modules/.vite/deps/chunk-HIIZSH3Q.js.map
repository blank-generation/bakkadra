{
  "version": 3,
  "sources": ["../../@baklavajs/engine/dist/esm/applyResult.js", "../../@baklavajs/engine/dist/esm/topologicalSorting.js", "../../@baklavajs/engine/dist/esm/baseEngine.js", "../../@baklavajs/engine/dist/esm/dependencyEngine.js"],
  "sourcesContent": ["/**\n * Apply the calculation result values to the output interfaces in the graph\n * @param result Calculation result\n * @param editor Editor instance\n */\nexport function applyResult(result, editor) {\n    const nodeMap = new Map();\n    editor.graphs.forEach((g) => {\n        g.nodes.forEach((n) => nodeMap.set(n.id, n));\n    });\n    result.forEach((intfValues, nodeId) => {\n        const node = nodeMap.get(nodeId);\n        if (!node) {\n            return;\n        }\n        intfValues.forEach((value, intfKey) => {\n            const intf = node.outputs[intfKey];\n            if (!intf) {\n                return;\n            }\n            intf.value = value;\n        });\n    });\n}\n", "import { Graph } from \"@baklavajs/core\";\nexport class CycleError extends Error {\n    constructor() {\n        super(\"Cycle detected\");\n    }\n}\nfunction isString(v) {\n    return typeof v === \"string\";\n}\nexport function sortTopologically(nodesOrGraph, pConnections) {\n    /** NodeInterface.id -> parent Node.id */\n    const interfaceIdToNodeId = new Map();\n    /** Node.id -> set of connected node.id */\n    const adjacency = new Map();\n    const connectionsFromNode = new Map();\n    let nodes;\n    let connections;\n    if (nodesOrGraph instanceof Graph) {\n        nodes = nodesOrGraph.nodes;\n        connections = nodesOrGraph.connections;\n    }\n    else {\n        if (!pConnections) {\n            throw new Error(\"Invalid argument value: expected array of connections\");\n        }\n        nodes = nodesOrGraph;\n        connections = pConnections;\n    }\n    nodes.forEach((n) => {\n        Object.values(n.inputs).forEach((intf) => interfaceIdToNodeId.set(intf.id, n.id));\n        Object.values(n.outputs).forEach((intf) => interfaceIdToNodeId.set(intf.id, n.id));\n    });\n    // build adjacency list\n    nodes.forEach((n) => {\n        const connectionsFromCurrentNode = connections.filter((c) => c.from && interfaceIdToNodeId.get(c.from.id) === n.id);\n        const adjacentNodes = new Set(connectionsFromCurrentNode.map((c) => interfaceIdToNodeId.get(c.to.id)).filter(isString));\n        adjacency.set(n.id, adjacentNodes);\n        connectionsFromNode.set(n, connectionsFromCurrentNode);\n    });\n    // startNodes are all nodes that don't have any input connected\n    const startNodes = nodes.slice();\n    connections.forEach((c) => {\n        const index = startNodes.findIndex((n) => interfaceIdToNodeId.get(c.to.id) === n.id);\n        if (index >= 0) {\n            startNodes.splice(index, 1);\n        }\n    });\n    const sorted = [];\n    while (startNodes.length > 0) {\n        const n = startNodes.pop();\n        sorted.push(n);\n        const nodesConnectedFromN = adjacency.get(n.id);\n        while (nodesConnectedFromN.size > 0) {\n            const mId = nodesConnectedFromN.values().next().value;\n            nodesConnectedFromN.delete(mId);\n            if (Array.from(adjacency.values()).every((connectedNodes) => !connectedNodes.has(mId))) {\n                const m = nodes.find((node) => node.id === mId);\n                startNodes.push(m);\n            }\n        }\n    }\n    if (Array.from(adjacency.values()).some((c) => c.size > 0)) {\n        throw new CycleError();\n    }\n    return {\n        calculationOrder: sorted,\n        connectionsFromNode,\n        interfaceIdToNodeId,\n    };\n}\nexport function containsCycle(nodesOrGraph, connections) {\n    try {\n        sortTopologically(nodesOrGraph, connections);\n        return false;\n    }\n    catch (err) {\n        if (err instanceof CycleError) {\n            return true;\n        }\n        throw err;\n    }\n}\n", "import { DummyConnection, } from \"@baklavajs/core\";\nimport { BaklavaEvent, DynamicSequentialHook, PreventableBaklavaEvent, SequentialHook } from \"@baklavajs/events\";\nimport { containsCycle } from \"./topologicalSorting\";\nexport var EngineStatus;\n(function (EngineStatus) {\n    /** The engine is currently running a calculation */\n    EngineStatus[\"Running\"] = \"Running\";\n    /** The engine is not currently running a calculation but will do so when the graph changes */\n    EngineStatus[\"Idle\"] = \"Idle\";\n    /** The engine is temporarily paused */\n    EngineStatus[\"Paused\"] = \"Paused\";\n    /** The engine is not running */\n    EngineStatus[\"Stopped\"] = \"Stopped\";\n})(EngineStatus || (EngineStatus = {}));\nexport class BaseEngine {\n    get status() {\n        if (this.isRunning) {\n            return EngineStatus.Running;\n        }\n        return this.internalStatus;\n    }\n    constructor(editor) {\n        this.editor = editor;\n        this.events = {\n            /**\n             * This event will be called before all the nodes `calculate` functions are called.\n             * The argument is the calculationData that the nodes will receive\n             */\n            beforeRun: new PreventableBaklavaEvent(this),\n            /**\n             * This event is called as soon as a run is completed.\n             * The argument is the result of the calculation.\n             */\n            afterRun: new BaklavaEvent(this),\n            statusChange: new BaklavaEvent(this),\n            /**\n             * This event is called before a node is calculated.\n             * It is not preventable since this would break calculation.\n             */\n            beforeNodeCalculation: new BaklavaEvent(this),\n            /** This event is called after a node has been calculated. */\n            afterNodeCalculation: new BaklavaEvent(this),\n        };\n        this.hooks = {\n            gatherCalculationData: new SequentialHook(this),\n            transferData: new DynamicSequentialHook(),\n        };\n        this.recalculateOrder = true;\n        /** the internal status will never be set to running, as this is determined by the running flag */\n        this.internalStatus = EngineStatus.Stopped;\n        this.isRunning = false;\n        this.editor.nodeEvents.update.subscribe(this, (data, node) => {\n            if (node.graph && !node.graph.loading && node.graph.activeTransactions === 0) {\n                this.internalOnChange(node, data !== null && data !== void 0 ? data : undefined);\n            }\n        });\n        this.editor.graphEvents.addNode.subscribe(this, (node, graph) => {\n            this.recalculateOrder = true;\n            if (!graph.loading && graph.activeTransactions === 0) {\n                this.internalOnChange();\n            }\n        });\n        this.editor.graphEvents.removeNode.subscribe(this, (node, graph) => {\n            this.recalculateOrder = true;\n            if (!graph.loading && graph.activeTransactions === 0) {\n                this.internalOnChange();\n            }\n        });\n        this.editor.graphEvents.addConnection.subscribe(this, (c, graph) => {\n            this.recalculateOrder = true;\n            if (!graph.loading && graph.activeTransactions === 0) {\n                this.internalOnChange();\n            }\n        });\n        this.editor.graphEvents.removeConnection.subscribe(this, (c, graph) => {\n            this.recalculateOrder = true;\n            if (!graph.loading && graph.activeTransactions === 0) {\n                this.internalOnChange();\n            }\n        });\n        this.editor.graphHooks.checkConnection.subscribe(this, (c) => this.checkConnection(c.from, c.to));\n    }\n    /** Start the engine. After started, it will run everytime the graph is changed. */\n    start() {\n        if (this.internalStatus === EngineStatus.Stopped) {\n            this.internalStatus = EngineStatus.Idle;\n            this.events.statusChange.emit(this.status);\n        }\n    }\n    /**\n     * Temporarily pause the engine.\n     * Use this method when you want to update the graph with the calculation results.\n     */\n    pause() {\n        if (this.internalStatus === EngineStatus.Idle) {\n            this.internalStatus = EngineStatus.Paused;\n            this.events.statusChange.emit(this.status);\n        }\n    }\n    /** Resume the engine from the paused state */\n    resume() {\n        if (this.internalStatus === EngineStatus.Paused) {\n            this.internalStatus = EngineStatus.Idle;\n            this.events.statusChange.emit(this.status);\n        }\n    }\n    /** Stop the engine */\n    stop() {\n        if (this.internalStatus === EngineStatus.Idle || this.internalStatus === EngineStatus.Paused) {\n            this.internalStatus = EngineStatus.Stopped;\n            this.events.statusChange.emit(this.status);\n        }\n    }\n    /**\n     * Calculate all nodes once.\n     * This will automatically calculate the node calculation order if necessary and\n     * transfer values between connected node interfaces.\n     * @param calculationData The data which is provided to each node's `calculate` method\n     * @param calculationArgs Additional data which is only provided to the engine\n     * @returns A promise that resolves to either\n     * - a map from each node's id to its calculated value (what the calculation function of the node returned)\n     * - null if the calculation was prevented from the beforeRun event\n     */\n    async runOnce(calculationData, ...args) {\n        if (this.events.beforeRun.emit(calculationData).prevented) {\n            return null;\n        }\n        try {\n            this.isRunning = true;\n            this.events.statusChange.emit(this.status);\n            if (this.recalculateOrder) {\n                this.calculateOrder();\n            }\n            const result = await this.execute(calculationData, ...args);\n            this.events.afterRun.emit(result);\n            return result;\n        }\n        finally {\n            this.isRunning = false;\n            this.events.statusChange.emit(this.status);\n        }\n    }\n    /** Check whether a connection can be created.\n     * A connection can not be created when it would result in a cyclic graph.\n     * @param from The interface from which the connection would start\n     * @param to The interface where the connection would end\n     * @returns Whether the connection can be created\n     */\n    checkConnection(from, to) {\n        if (from.templateId) {\n            const newFrom = this.findInterfaceByTemplateId(this.editor.graph.nodes, from.templateId);\n            if (!newFrom) {\n                return { connectionAllowed: true, connectionsInDanger: [] };\n            }\n            from = newFrom;\n        }\n        if (to.templateId) {\n            const newTo = this.findInterfaceByTemplateId(this.editor.graph.nodes, to.templateId);\n            if (!newTo) {\n                return { connectionAllowed: true, connectionsInDanger: [] };\n            }\n            to = newTo;\n        }\n        const dc = new DummyConnection(from, to);\n        let copy = this.editor.graph.connections.slice();\n        if (!to.allowMultipleConnections) {\n            copy = copy.filter((conn) => conn.to !== to);\n        }\n        copy.push(dc);\n        if (containsCycle(this.editor.graph.nodes, copy)) {\n            return { connectionAllowed: false, connectionsInDanger: [] };\n        }\n        return {\n            connectionAllowed: true,\n            connectionsInDanger: to.allowMultipleConnections\n                ? []\n                : this.editor.graph.connections.filter((c) => c.to === to),\n        };\n    }\n    /**\n     * Force the engine to recalculate the node execution order before the next run.\n     * This is normally done automatically. Use this method if the\n     * default change detection does not work in your scenario.\n     */\n    calculateOrder() {\n        this.recalculateOrder = true;\n    }\n    /**\n     * Use the `gatherCalculationData` hook to get the calculation data\n     * @param args The calculation arguments with which the engine's calculate method will be called (in addition to the `calculationData`)\n     * @returns The calculation result\n     */\n    async calculateWithoutData(...args) {\n        const calculationData = this.hooks.gatherCalculationData.execute(undefined);\n        return await this.runOnce(calculationData, ...args);\n    }\n    /**\n     * Validate the result of a node's `calculate` method. A result is valid if:\n     * - is has the correct format (it must be an object, where the key is the interface key and the value is the output value for that interface)\n     * - every output interface has a value assigned to it (null and undefined are also valid, but the key must exist in the object)\n     * @param node The node which produced the output data\n     * @param output The result of the node's `calculate` method\n     */\n    validateNodeCalculationOutput(node, output) {\n        if (typeof output !== \"object\") {\n            throw new Error(`Invalid calculation return value from node ${node.id} (type ${node.type})`);\n        }\n        Object.keys(node.outputs).forEach((k) => {\n            if (!(k in output)) {\n                throw new Error(`Calculation return value from node ${node.id} (type ${node.type}) is missing key \"${k}\"`);\n            }\n        });\n    }\n    internalOnChange(updatedNode, data) {\n        if (this.internalStatus === EngineStatus.Idle) {\n            this.onChange(this.recalculateOrder, updatedNode, data);\n        }\n    }\n    findInterfaceByTemplateId(nodes, templateId) {\n        for (const n of nodes) {\n            for (const intf of [...Object.values(n.inputs), ...Object.values(n.outputs)]) {\n                if (intf.templateId === templateId) {\n                    return intf;\n                }\n            }\n        }\n        return null;\n    }\n}\n", "import { BaseEngine } from \"./baseEngine\";\nimport { sortTopologically } from \"./topologicalSorting\";\nexport const allowMultipleConnections = (intf) => {\n    intf.allowMultipleConnections = true;\n};\nexport class DependencyEngine extends BaseEngine {\n    constructor(editor) {\n        super(editor);\n        this.order = new Map();\n    }\n    start() {\n        super.start();\n        this.recalculateOrder = true;\n        void this.calculateWithoutData();\n    }\n    async runGraph(graph, inputs, calculationData) {\n        if (!this.order.has(graph.id)) {\n            this.order.set(graph.id, sortTopologically(graph));\n        }\n        const { calculationOrder, connectionsFromNode } = this.order.get(graph.id);\n        const result = new Map();\n        for (const n of calculationOrder) {\n            const inputsForNode = {};\n            Object.entries(n.inputs).forEach(([k, v]) => {\n                inputsForNode[k] = this.getInterfaceValue(inputs, v.id);\n            });\n            this.events.beforeNodeCalculation.emit({ inputValues: inputsForNode, node: n });\n            let r;\n            if (n.calculate) {\n                r = await n.calculate(inputsForNode, { globalValues: calculationData, engine: this });\n            }\n            else {\n                r = {};\n                for (const [k, intf] of Object.entries(n.outputs)) {\n                    r[k] = this.getInterfaceValue(inputs, intf.id);\n                }\n            }\n            this.validateNodeCalculationOutput(n, r);\n            this.events.afterNodeCalculation.emit({ outputValues: r, node: n });\n            result.set(n.id, new Map(Object.entries(r)));\n            if (connectionsFromNode.has(n)) {\n                connectionsFromNode.get(n).forEach((c) => {\n                    var _a;\n                    const intfKey = (_a = Object.entries(n.outputs).find(([, intf]) => intf.id === c.from.id)) === null || _a === void 0 ? void 0 : _a[0];\n                    if (!intfKey) {\n                        throw new Error(`Could not find key for interface ${c.from.id}\\n` +\n                            \"This is likely a Baklava internal issue. Please report it on GitHub.\");\n                    }\n                    const v = this.hooks.transferData.execute(r[intfKey], c);\n                    if (c.to.allowMultipleConnections) {\n                        if (inputs.has(c.to.id)) {\n                            inputs.get(c.to.id).push(v);\n                        }\n                        else {\n                            inputs.set(c.to.id, [v]);\n                        }\n                    }\n                    else {\n                        inputs.set(c.to.id, v);\n                    }\n                });\n            }\n        }\n        return result;\n    }\n    async execute(calculationData) {\n        if (this.recalculateOrder) {\n            this.order.clear();\n            this.recalculateOrder = false;\n        }\n        const inputValues = this.getInputValues(this.editor.graph);\n        return await this.runGraph(this.editor.graph, inputValues, calculationData);\n    }\n    getInputValues(graph) {\n        // Gather all values of the unconnected inputs.\n        // maps NodeInterface.id -> value\n        // The reason it is done here and not during calculation is\n        // that this way we prevent race conditions because calculations can be async.\n        // For the same reason, we need to gather all output values for nodes that do not have a calculate function.\n        const inputValues = new Map();\n        for (const n of graph.nodes) {\n            Object.values(n.inputs).forEach((ni) => {\n                if (ni.connectionCount === 0) {\n                    inputValues.set(ni.id, ni.value);\n                }\n            });\n            if (!n.calculate) {\n                Object.values(n.outputs).forEach((ni) => {\n                    inputValues.set(ni.id, ni.value);\n                });\n            }\n        }\n        return inputValues;\n    }\n    onChange(recalculateOrder) {\n        this.recalculateOrder = recalculateOrder || this.recalculateOrder;\n        void this.calculateWithoutData();\n    }\n    getInterfaceValue(values, id) {\n        if (!values.has(id)) {\n            throw new Error(`Could not find value for interface ${id}\\n` +\n                \"This is likely a Baklava internal issue. Please report it on GitHub.\");\n        }\n        return values.get(id);\n    }\n}\n"],
  "mappings": "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",
  "names": ["EngineStatus"]
}
