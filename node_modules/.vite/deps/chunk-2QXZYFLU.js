import {
  Fragment,
  Transition,
  TransitionGroup,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineComponent,
  getCurrentScope,
  inject,
  isRef,
  markRaw,
  nextTick,
  normalizeClass,
  normalizeStyle,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  onUpdated,
  openBlock,
  provide,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  shallowReadonly,
  shallowRef,
  toDisplayString,
  toRef,
  toRefs,
  toValue,
  unref,
  vModelText,
  vShow,
  watch,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-FIAHBV72.js";
import {
  Editor,
  GRAPH_INPUT_NODE_TYPE,
  GRAPH_NODE_TYPE_PREFIX,
  GRAPH_OUTPUT_NODE_TYPE,
  Graph,
  GraphInputNode,
  GraphOutputNode,
  GraphTemplate,
  NodeInterface,
  SequentialHook,
  getGraphNodeTypeString
} from "./chunk-7FQOAGDZ.js";

// node_modules/@baklavajs/renderer-vue/dist/renderer-vue.es.mjs
var INPUT_ELEMENT_TAGS = ["INPUT", "TEXTAREA", "SELECT"];
function isInputElement(el) {
  return INPUT_ELEMENT_TAGS.includes(el.tagName);
}
function getNodePosition(node) {
  return node.position;
}
function setNodePosition(node, x, y) {
  node.position.x = x;
  node.position.y = y;
}
var viewModelRef = null;
function providePlugin(viewModel) {
  viewModelRef = viewModel;
}
function useViewModel() {
  if (!viewModelRef) {
    throw new Error("providePlugin() must be called before usePlugin()");
  }
  return {
    viewModel: viewModelRef
  };
}
function useGraph() {
  const { viewModel } = useViewModel();
  return {
    graph: toRef(viewModel.value, "displayedGraph"),
    switchGraph: viewModel.value.switchGraph
  };
}
function useDragMove(positionRef) {
  const { graph } = useGraph();
  const draggingStartPoint = ref(null);
  const draggingStartPosition = ref(null);
  const dragging = computed(() => !!draggingStartPoint.value);
  const onPointerDown = (ev) => {
    draggingStartPoint.value = {
      x: ev.pageX,
      y: ev.pageY
    };
    draggingStartPosition.value = {
      x: positionRef.value.x,
      y: positionRef.value.y
    };
  };
  const onPointerMove = (ev) => {
    if (draggingStartPoint.value) {
      const dx = ev.pageX - draggingStartPoint.value.x;
      const dy = ev.pageY - draggingStartPoint.value.y;
      positionRef.value.x = draggingStartPosition.value.x + dx / graph.value.scaling;
      positionRef.value.y = draggingStartPosition.value.y + dy / graph.value.scaling;
    }
  };
  const onPointerUp = () => {
    draggingStartPoint.value = null;
    draggingStartPosition.value = null;
  };
  return { dragging, onPointerDown, onPointerMove, onPointerUp };
}
function checkRecursion(editor, currentGraph, graphNodeType) {
  if (!currentGraph.template) {
    return false;
  }
  if (getGraphNodeTypeString(currentGraph.template) === graphNodeType) {
    return true;
  }
  const template = editor.graphTemplates.find((t) => getGraphNodeTypeString(t) === graphNodeType);
  if (!template) {
    return false;
  }
  const containedGraphNodes = template.nodes.filter((n) => n.type.startsWith(GRAPH_NODE_TYPE_PREFIX));
  return containedGraphNodes.some((n) => checkRecursion(editor, currentGraph, n.type));
}
function useNodeCategories(viewModel) {
  return computed(() => {
    const nodeTypeEntries = Array.from(viewModel.value.editor.nodeTypes.entries());
    const categoryNames = new Set(nodeTypeEntries.map(([, ni]) => ni.category));
    const categories = [];
    for (const c of categoryNames.values()) {
      let nodeTypesInCategory = nodeTypeEntries.filter(([, ni]) => ni.category === c);
      if (viewModel.value.displayedGraph.template) {
        nodeTypesInCategory = nodeTypesInCategory.filter(
          ([nt]) => !checkRecursion(viewModel.value.editor, viewModel.value.displayedGraph, nt)
        );
      } else {
        nodeTypesInCategory = nodeTypesInCategory.filter(
          ([nt]) => ![GRAPH_INPUT_NODE_TYPE, GRAPH_OUTPUT_NODE_TYPE].includes(nt)
        );
      }
      if (nodeTypesInCategory.length > 0) {
        categories.push({
          name: c,
          nodeTypes: Object.fromEntries(nodeTypesInCategory)
        });
      }
    }
    categories.sort((a, b) => {
      if (a.name === "default") {
        return -1;
      } else if (b.name === "default") {
        return 1;
      } else {
        return a.name > b.name ? 1 : -1;
      }
    });
    return categories;
  });
}
function useTransform() {
  const { graph } = useGraph();
  const transform = (x, y) => {
    const tx = x / graph.value.scaling - graph.value.panning.x;
    const ty = y / graph.value.scaling - graph.value.panning.y;
    return [tx, ty];
  };
  return { transform };
}
function usePanZoom() {
  const { graph } = useGraph();
  let pointerCache = [];
  let prevDiff = -1;
  let midpoint = { x: 0, y: 0 };
  const panningRef = computed(() => graph.value.panning);
  const dragMove = useDragMove(panningRef);
  const styles = computed(() => ({
    "transform-origin": "0 0",
    "transform": `scale(${graph.value.scaling}) translate(${graph.value.panning.x}px, ${graph.value.panning.y}px)`
  }));
  const applyZoom = (centerX, centerY, newScale) => {
    const currentPoint = [
      centerX / graph.value.scaling - graph.value.panning.x,
      centerY / graph.value.scaling - graph.value.panning.y
    ];
    const newPoint = [centerX / newScale - graph.value.panning.x, centerY / newScale - graph.value.panning.y];
    const diff = [newPoint[0] - currentPoint[0], newPoint[1] - currentPoint[1]];
    graph.value.panning.x += diff[0];
    graph.value.panning.y += diff[1];
    graph.value.scaling = newScale;
  };
  const onMouseWheel = (ev) => {
    ev.preventDefault();
    let scrollAmount = ev.deltaY;
    if (ev.deltaMode === 1) {
      scrollAmount *= 32;
    }
    const newScale = graph.value.scaling * (1 - scrollAmount / 3e3);
    applyZoom(ev.offsetX, ev.offsetY, newScale);
  };
  const getCoordsFromCache = () => ({
    ax: pointerCache[0].clientX,
    ay: pointerCache[0].clientY,
    bx: pointerCache[1].clientX,
    by: pointerCache[1].clientY
  });
  const onPointerDown = (ev) => {
    pointerCache.push(ev);
    dragMove.onPointerDown(ev);
    if (pointerCache.length === 2) {
      const { ax, ay, bx, by } = getCoordsFromCache();
      midpoint = {
        x: ax + (bx - ax) / 2,
        y: ay + (by - ay) / 2
      };
    }
  };
  const onPointerMove = (ev) => {
    for (let i = 0; i < pointerCache.length; i++) {
      if (ev.pointerId == pointerCache[i].pointerId) {
        pointerCache[i] = ev;
        break;
      }
    }
    if (pointerCache.length == 2) {
      const { ax, ay, bx, by } = getCoordsFromCache();
      const dx = ax - bx;
      const dy = ay - by;
      const curDiff = Math.sqrt(dx * dx + dy * dy);
      if (prevDiff > 0) {
        const newScale = graph.value.scaling * (1 + (curDiff - prevDiff) / 500);
        applyZoom(midpoint.x, midpoint.y, newScale);
      }
      prevDiff = curDiff;
    } else {
      dragMove.onPointerMove(ev);
    }
  };
  const onPointerUp = (ev) => {
    pointerCache = pointerCache.filter((p) => p.pointerId !== ev.pointerId);
    prevDiff = -1;
    dragMove.onPointerUp();
  };
  return { styles, ...dragMove, onPointerDown, onPointerMove, onPointerUp, onMouseWheel };
}
var TemporaryConnectionState = ((TemporaryConnectionState2) => {
  TemporaryConnectionState2[TemporaryConnectionState2["NONE"] = 0] = "NONE";
  TemporaryConnectionState2[TemporaryConnectionState2["ALLOWED"] = 1] = "ALLOWED";
  TemporaryConnectionState2[TemporaryConnectionState2["FORBIDDEN"] = 2] = "FORBIDDEN";
  return TemporaryConnectionState2;
})(TemporaryConnectionState || {});
var TEMPORARY_CONNECTION_HANDLER_INJECTION_SYMBOL = Symbol();
function provideTemporaryConnection() {
  const { graph } = useGraph();
  const temporaryConnection = ref(null);
  const hoveringOver = ref(null);
  const onMouseMove = (ev) => {
    if (temporaryConnection.value) {
      temporaryConnection.value.mx = ev.offsetX / graph.value.scaling - graph.value.panning.x;
      temporaryConnection.value.my = ev.offsetY / graph.value.scaling - graph.value.panning.y;
    }
  };
  const onMouseDown = () => {
    if (hoveringOver.value) {
      if (temporaryConnection.value) {
        return;
      }
      const connection = graph.value.connections.find((c) => c.to === hoveringOver.value);
      if (hoveringOver.value.isInput && connection) {
        temporaryConnection.value = {
          status: TemporaryConnectionState.NONE,
          from: connection.from
        };
        graph.value.removeConnection(connection);
      } else {
        temporaryConnection.value = {
          status: TemporaryConnectionState.NONE,
          from: hoveringOver.value
        };
      }
      temporaryConnection.value.mx = void 0;
      temporaryConnection.value.my = void 0;
    }
  };
  const onMouseUp = () => {
    if (temporaryConnection.value && hoveringOver.value) {
      if (temporaryConnection.value.from === hoveringOver.value) {
        return;
      }
      graph.value.addConnection(temporaryConnection.value.from, temporaryConnection.value.to);
    }
    temporaryConnection.value = null;
  };
  const hoveredOver = (ni) => {
    hoveringOver.value = ni ?? null;
    if (ni && temporaryConnection.value) {
      temporaryConnection.value.to = ni;
      const checkConnectionResult = graph.value.checkConnection(
        temporaryConnection.value.from,
        temporaryConnection.value.to
      );
      temporaryConnection.value.status = checkConnectionResult.connectionAllowed ? TemporaryConnectionState.ALLOWED : TemporaryConnectionState.FORBIDDEN;
      if (checkConnectionResult.connectionAllowed) {
        const ids = checkConnectionResult.connectionsInDanger.map((c) => c.id);
        graph.value.connections.forEach((c) => {
          if (ids.includes(c.id)) {
            c.isInDanger = true;
          }
        });
      }
    } else if (!ni && temporaryConnection.value) {
      temporaryConnection.value.to = void 0;
      temporaryConnection.value.status = TemporaryConnectionState.NONE;
      graph.value.connections.forEach((c) => {
        c.isInDanger = false;
      });
    }
  };
  provide(TEMPORARY_CONNECTION_HANDLER_INJECTION_SYMBOL, {
    temporaryConnection,
    hoveredOver
  });
  return { temporaryConnection, onMouseMove, onMouseDown, onMouseUp, hoveredOver };
}
function useTemporaryConnection() {
  const temporaryConnection = inject(TEMPORARY_CONNECTION_HANDLER_INJECTION_SYMBOL);
  if (!temporaryConnection) {
    throw new Error("useTemporaryConnection must be used within a BaklavaEditor");
  }
  return temporaryConnection;
}
function useContextMenu(viewModel) {
  const show = ref(false);
  const x = ref(0);
  const y = ref(0);
  const categories = useNodeCategories(viewModel);
  const { transform } = useTransform();
  const nodeItems = computed(() => {
    let defaultNodes = [];
    const categoryItems = {};
    for (const category of categories.value) {
      const mappedNodes = Object.entries(category.nodeTypes).map(([nodeType, info]) => ({
        label: info.title,
        value: "addNode:" + nodeType
      }));
      if (category.name === "default") {
        defaultNodes = mappedNodes;
      } else {
        categoryItems[category.name] = mappedNodes;
      }
    }
    const menuItems = [
      ...Object.entries(categoryItems).map(([category, items2]) => ({
        label: category,
        submenu: items2
      }))
    ];
    if (menuItems.length > 0 && defaultNodes.length > 0) {
      menuItems.push({ isDivider: true });
    }
    menuItems.push(...defaultNodes);
    return menuItems;
  });
  const items = computed(() => {
    if (viewModel.value.settings.contextMenu.additionalItems.length === 0) {
      return nodeItems.value;
    } else {
      return [
        { label: "Add node", submenu: nodeItems.value },
        ...viewModel.value.settings.contextMenu.additionalItems.map((item) => {
          if ("isDivider" in item || "submenu" in item) {
            return item;
          } else {
            return {
              label: item.label,
              value: "command:" + item.command,
              disabled: !viewModel.value.commandHandler.canExecuteCommand(item.command)
            };
          }
        })
      ];
    }
  });
  function open(ev) {
    const target = ev.target;
    if (!(target instanceof Element) || isInputElement(target)) {
      return;
    }
    ev.preventDefault();
    show.value = true;
    const bounding = target.getBoundingClientRect();
    const editor = target.closest(".baklava-editor");
    const editorBounding = editor.getBoundingClientRect();
    x.value = bounding.x + ev.offsetX - editorBounding.x;
    y.value = bounding.y + ev.offsetY - editorBounding.y;
  }
  function onClick(value) {
    if (value.startsWith("addNode:")) {
      const nodeType = value.substring("addNode:".length);
      const nodeInformation = viewModel.value.editor.nodeTypes.get(nodeType);
      if (!nodeInformation) {
        return;
      }
      const instance = reactive(new nodeInformation.type());
      viewModel.value.displayedGraph.addNode(instance);
      const [transformedX, transformedY] = transform(x.value, y.value);
      instance.position.x = transformedX;
      instance.position.y = transformedY;
    } else if (value.startsWith("command:")) {
      const command = value.substring("command:".length);
      if (viewModel.value.commandHandler.canExecuteCommand(command)) {
        viewModel.value.commandHandler.executeCommand(command);
      }
    }
  }
  return { show, x, y, items, open, onClick };
}
var START_SELECTION_BOX_COMMAND = "START_SELECTION_BOX";
function useSelectionBox(editorEl) {
  const { viewModel } = useViewModel();
  const { graph } = useGraph();
  const nodes = computed(() => graph.value.nodes);
  const startSelection = ref(false);
  const isSelecting = ref(false);
  const start = ref([0, 0]);
  const end = ref([0, 0]);
  watch(
    viewModel,
    () => {
      if (viewModel.value.commandHandler.hasCommand(START_SELECTION_BOX_COMMAND)) {
        return;
      }
      viewModel.value.commandHandler.registerCommand(START_SELECTION_BOX_COMMAND, {
        canExecute: () => true,
        execute() {
          startSelection.value = true;
        }
      });
      viewModel.value.commandHandler.registerHotkey(["b"], START_SELECTION_BOX_COMMAND);
    },
    { immediate: true }
  );
  function getCoordinatesFromEvent(ev) {
    return [
      ev.clientX - editorEl.value.getBoundingClientRect().left,
      ev.clientY - editorEl.value.getBoundingClientRect().top
    ];
  }
  function onPointerDown(ev) {
    if (startSelection.value) {
      isSelecting.value = true;
      startSelection.value = false;
      start.value = getCoordinatesFromEvent(ev);
      end.value = getCoordinatesFromEvent(ev);
      document.addEventListener("pointermove", onPointerMove);
      document.addEventListener("pointerup", onPointerUp);
      return true;
    }
    return false;
  }
  function onPointerMove(ev) {
    start.value = getCoordinatesFromEvent(ev);
  }
  function onPointerUp(ev) {
    document.removeEventListener("pointermove", onPointerMove);
    document.removeEventListener("pointerup", onPointerUp);
    start.value = getCoordinatesFromEvent(ev);
    isSelecting.value = false;
    const selectedNodes = getNodesInSelection();
    for (const node of selectedNodes) {
      viewModel.value.displayedGraph.selectedNodes.push(node);
    }
  }
  function getNodesInSelection() {
    const selectionBoxRect = getSelectionBoxRect();
    const editor = document.querySelector(".baklava-editor");
    const editorBounding = editor.getBoundingClientRect();
    return nodes.value.filter((node) => {
      const nodeRect = getNodeRect2(node, editorBounding);
      return isRectOverlap(selectionBoxRect, nodeRect);
    });
  }
  function getSelectionBoxRect() {
    return {
      left: Math.min(start.value[0], end.value[0]),
      top: Math.min(start.value[1], end.value[1]),
      right: Math.max(start.value[0], end.value[0]),
      bottom: Math.max(start.value[1], end.value[1])
    };
  }
  function getNodeRect2(node, editorBounding) {
    const domNode = document.getElementById(node.id);
    const rect = domNode ? domNode.getBoundingClientRect() : { x: 0, y: 0, width: 0, height: 0 };
    const left = rect.x - editorBounding.left;
    const top = rect.y - editorBounding.top;
    return {
      left,
      top,
      right: left + rect.width,
      bottom: top + rect.height
    };
  }
  function isRectOverlap(rect1, rect2) {
    return rect1.left < rect2.right && rect1.right > rect2.left && rect1.top < rect2.bottom && rect1.bottom > rect2.top;
  }
  function getStyles() {
    return {
      width: Math.abs(end.value[0] - start.value[0]) + "px",
      height: Math.abs(end.value[1] - start.value[1]) + "px",
      left: (end.value[0] > start.value[0] ? start.value[0] : end.value[0]) + "px",
      top: (end.value[1] > start.value[1] ? start.value[1] : end.value[1]) + "px"
    };
  }
  return reactive({
    startSelection,
    isSelecting,
    start,
    end,
    onPointerDown,
    getStyles
  });
}
var _sfc_main$y = defineComponent({
  setup() {
    const { viewModel } = useViewModel();
    const { graph } = useGraph();
    const styles = computed(() => {
      const config = viewModel.value.settings.background;
      const positionLeft = graph.value.panning.x * graph.value.scaling;
      const positionTop = graph.value.panning.y * graph.value.scaling;
      const size = graph.value.scaling * config.gridSize;
      const subSize = size / config.gridDivision;
      const backgroundSize = `${size}px ${size}px, ${size}px ${size}px`;
      const subGridBackgroundSize = graph.value.scaling > config.subGridVisibleThreshold ? `, ${subSize}px ${subSize}px, ${subSize}px ${subSize}px` : "";
      return {
        backgroundPosition: `left ${positionLeft}px top ${positionTop}px`,
        backgroundSize: `${backgroundSize} ${subGridBackgroundSize}`
      };
    });
    return { styles };
  }
});
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "background",
    style: normalizeStyle(_ctx.styles)
  }, null, 4);
}
var Background = _export_sfc(_sfc_main$y, [["render", _sfc_render$p]]);
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var toString = Object.prototype.toString;
var isObject = (val) => toString.call(val) === "[object Object]";
var noop = () => {
};
var isIOS = getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function objectPick(obj, keys2, omitUndefined = false) {
  return keys2.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || obj[k] !== void 0)
        n[k] = obj[k];
    }
    return n;
  }, {});
}
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function toRefs2(objectRef, options = {}) {
  if (!isRef(objectRef))
    return toRefs(objectRef);
  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};
  for (const key in objectRef.value) {
    result[key] = customRef(() => ({
      get() {
        return objectRef.value[key];
      },
      set(v) {
        var _a;
        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;
        if (replaceRef) {
          if (Array.isArray(objectRef.value)) {
            const copy = [...objectRef.value];
            copy[key] = v;
            objectRef.value = copy;
          } else {
            const newObject = { ...objectRef.value, [key]: v };
            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));
            objectRef.value = newObject;
          }
        } else {
          objectRef.value[key] = v;
        }
      }
    }));
  }
  return result;
}
function watchImmediate(source, cb, options) {
  return watch(
    source,
    cb,
    {
      ...options,
      immediate: true
    }
  );
}
var defaultWindow = isClient ? window : void 0;
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
function useEventListener(...args) {
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed(() => {
    const test = toArray(toValue(args[0])).filter((e) => e != null);
    return test.every((e) => typeof e !== "string") ? test : void 0;
  });
  const stopWatch = watchImmediate(
    () => {
      var _a, _b;
      return [
        (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),
        toArray(toValue(firstParamTargets.value ? args[1] : args[0])),
        toArray(unref(firstParamTargets.value ? args[2] : args[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(firstParamTargets.value ? args[3] : args[2])
      ];
    },
    ([raw_targets, raw_events, raw_listeners, raw_options]) => {
      cleanup();
      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
        return;
      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
      cleanups.push(
        ...raw_targets.flatMap(
          (el) => raw_events.flatMap(
            (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))
          )
        )
      );
    },
    { flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(cleanup);
  return stop;
}
var _iOSWorkaround = false;
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false, controls = false } = options;
  if (!window2) {
    return controls ? { stop: noop, cancel: noop, trigger: noop } : noop;
  }
  if (isIOS && !_iOSWorkaround) {
    _iOSWorkaround = true;
    const listenerOptions = { passive: true };
    Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop, listenerOptions));
    window2.document.documentElement.addEventListener("click", noop, listenerOptions);
  }
  let shouldListen = true;
  const shouldIgnore = (event) => {
    return toValue(ignore).some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
      } else {
        const el = unrefElement(target2);
        return el && (event.target === el || event.composedPath().includes(el));
      }
    });
  };
  function hasMultipleRoots(target2) {
    const vm = toValue(target2);
    return vm && vm.$.subTree.shapeFlag === 16;
  }
  function checkMultipleRoots(target2, event) {
    const vm = toValue(target2);
    const children = vm.$.subTree && vm.$.subTree.children;
    if (children == null || !Array.isArray(children))
      return false;
    return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));
  }
  const listener = (event) => {
    const el = unrefElement(target);
    if (event.target == null)
      return;
    if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event))
      return;
    if (!el || el === event.target || event.composedPath().includes(el))
      return;
    if ("detail" in event && event.detail === 0)
      shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  let isProcessingClick = false;
  const cleanup = [
    useEventListener(window2, "click", (event) => {
      if (!isProcessingClick) {
        isProcessingClick = true;
        setTimeout(() => {
          isProcessingClick = false;
        }, 0);
        listener(event);
      }
    }, { passive: true, capture }),
    useEventListener(window2, "pointerdown", (e) => {
      const el = unrefElement(target);
      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));
    }, { passive: true }),
    detectIframe && useEventListener(window2, "blur", (event) => {
      setTimeout(() => {
        var _a;
        const el = unrefElement(target);
        if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement))) {
          handler(event);
        }
      }, 0);
    }, { passive: true })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn) => fn());
  if (controls) {
    return {
      stop,
      cancel: () => {
        shouldListen = false;
      },
      trigger: (event) => {
        shouldListen = true;
        listener(event);
        shouldListen = false;
      }
    };
  }
  return stop;
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
function usePointer(options = {}) {
  const {
    target = defaultWindow
  } = options;
  const isInside = shallowRef(false);
  const state = ref(options.initialValue || {});
  Object.assign(state.value, defaultState, state.value);
  const handler = (event) => {
    isInside.value = true;
    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))
      return;
    state.value = objectPick(event, keys, false);
  };
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["pointerdown", "pointermove", "pointerup"], handler, listenerOptions);
    useEventListener(target, "pointerleave", () => isInside.value = false, listenerOptions);
  }
  return {
    ...toRefs2(state),
    isInside
  };
}
var _hoisted_1$s = ["onMouseenter", "onMouseleave", "onClick"];
var _hoisted_2$9 = { class: "flex-fill" };
var _hoisted_3$7 = {
  key: 0,
  class: "__submenu-icon",
  style: { "line-height": "1em" }
};
var _sfc_main$x = defineComponent({
  __name: "ContextMenu",
  props: {
    modelValue: { type: Boolean },
    items: {},
    x: { default: 0 },
    y: { default: 0 },
    isNested: { type: Boolean, default: false },
    isFlipped: { default: () => ({ x: false, y: false }) },
    flippable: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    let activeMenuResetTimeout = null;
    const el = ref(null);
    const activeMenu = ref(-1);
    const height = ref(0);
    const rootIsFlipped = ref({ x: false, y: false });
    const flippedX = computed(() => props.flippable && (rootIsFlipped.value.x || props.isFlipped.x));
    const flippedY = computed(() => props.flippable && (rootIsFlipped.value.y || props.isFlipped.y));
    const styles = computed(() => {
      const s = {};
      if (!props.isNested) {
        s.top = (flippedY.value ? props.y - height.value : props.y) + "px";
        s.left = props.x + "px";
      }
      return s;
    });
    const classes = computed(() => {
      return {
        "--flipped-x": flippedX.value,
        "--flipped-y": flippedY.value,
        "--nested": props.isNested
      };
    });
    const itemsWithHoverProperty = computed(() => props.items.map((i) => ({ ...i, hover: false })));
    watch([() => props.y, () => props.items], () => {
      var _a, _b, _c, _d;
      height.value = props.items.length * 30;
      const parentWidth = ((_b = (_a = el.value) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.offsetWidth) ?? 0;
      const parentHeight = ((_d = (_c = el.value) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.offsetHeight) ?? 0;
      rootIsFlipped.value.x = !props.isNested && props.x > parentWidth * 0.75;
      rootIsFlipped.value.y = !props.isNested && props.y + height.value > parentHeight - 20;
    });
    onClickOutside(el, () => {
      if (props.modelValue) {
        emit("update:modelValue", false);
      }
    });
    const onClick = (item) => {
      if (!item.submenu && item.value) {
        emit("click", item.value);
        emit("update:modelValue", false);
      }
    };
    const onChildClick = (value) => {
      emit("click", value);
      activeMenu.value = -1;
      if (!props.isNested) {
        emit("update:modelValue", false);
      }
    };
    const onMouseEnter = (event, index) => {
      if (props.items[index].submenu) {
        activeMenu.value = index;
        if (activeMenuResetTimeout !== null) {
          clearTimeout(activeMenuResetTimeout);
          activeMenuResetTimeout = null;
        }
      }
    };
    const onMouseLeave = (event, index) => {
      if (props.items[index].submenu) {
        activeMenuResetTimeout = window.setTimeout(() => {
          activeMenu.value = -1;
          activeMenuResetTimeout = null;
        }, 200);
      }
    };
    return (_ctx, _cache) => {
      const _component_ContextMenu = resolveComponent("ContextMenu", true);
      return openBlock(), createBlock(Transition, { name: "slide-fade" }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            ref_key: "el",
            ref: el,
            class: normalizeClass(["baklava-context-menu", classes.value]),
            style: normalizeStyle(styles.value)
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(itemsWithHoverProperty.value, (item, index) => {
              return openBlock(), createElementBlock(Fragment, null, [
                item.isDivider ? (openBlock(), createElementBlock("div", {
                  key: `d-${index}`,
                  class: "divider"
                })) : (openBlock(), createElementBlock("div", {
                  key: `i-${index}`,
                  class: normalizeClass(["item", { "submenu": !!item.submenu, "--disabled": !!item.disabled }]),
                  onMouseenter: ($event) => onMouseEnter($event, index),
                  onMouseleave: ($event) => onMouseLeave($event, index),
                  onClick: withModifiers(($event) => onClick(item), ["stop", "prevent"])
                }, [
                  createBaseVNode("div", _hoisted_2$9, toDisplayString(item.label), 1),
                  item.submenu ? (openBlock(), createElementBlock("div", _hoisted_3$7, _cache[0] || (_cache[0] = [
                    createBaseVNode("svg", {
                      width: "13",
                      height: "13",
                      viewBox: "-60 120 250 250"
                    }, [
                      createBaseVNode("path", {
                        d: "M160.875 279.5625 L70.875 369.5625 L70.875 189.5625 L160.875 279.5625 Z",
                        stroke: "none",
                        fill: "white"
                      })
                    ], -1)
                  ]))) : createCommentVNode("", true),
                  item.submenu ? (openBlock(), createBlock(_component_ContextMenu, {
                    key: 1,
                    "model-value": activeMenu.value === index,
                    items: item.submenu,
                    "is-nested": true,
                    "is-flipped": { x: flippedX.value, y: flippedY.value },
                    flippable: _ctx.flippable,
                    onClick: onChildClick
                  }, null, 8, ["model-value", "items", "is-flipped", "flippable"])) : createCommentVNode("", true)
                ], 42, _hoisted_1$s))
              ], 64);
            }), 256))
          ], 6), [
            [vShow, _ctx.modelValue]
          ])
        ]),
        _: 1
      });
    };
  }
});
var _sfc_main$w = {};
var _hoisted_1$r = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "baklava-icon",
  width: "16",
  height: "16",
  viewBox: "0 0 24 24",
  "stroke-width": "2",
  stroke: "currentColor",
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _sfc_render$o(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$r, _cache[0] || (_cache[0] = [
    createBaseVNode("path", {
      stroke: "none",
      d: "M0 0h24v24H0z",
      fill: "none"
    }, null, -1),
    createBaseVNode("circle", {
      cx: "12",
      cy: "12",
      r: "1"
    }, null, -1),
    createBaseVNode("circle", {
      cx: "12",
      cy: "19",
      r: "1"
    }, null, -1),
    createBaseVNode("circle", {
      cx: "12",
      cy: "5",
      r: "1"
    }, null, -1)
  ]));
}
var VerticalDots = _export_sfc(_sfc_main$w, [["render", _sfc_render$o]]);
var _hoisted_1$q = ["id"];
var _hoisted_2$8 = {
  key: 0,
  class: "__tooltip"
};
var _hoisted_3$6 = {
  key: 2,
  class: "align-middle"
};
var _sfc_main$v = defineComponent({
  __name: "NodeInterface",
  props: {
    node: {},
    intf: {}
  },
  setup(__props) {
    const ellipsis = (value, characters = 100) => {
      const stringValue = typeof (value == null ? void 0 : value.toString) === "function" ? String(value) : "";
      if (stringValue.length > characters) {
        return stringValue.slice(0, characters) + "...";
      }
      return stringValue;
    };
    const props = __props;
    const { viewModel } = useViewModel();
    const { hoveredOver, temporaryConnection } = useTemporaryConnection();
    const el = ref(null);
    const isConnected = computed(() => props.intf.connectionCount > 0);
    const isHovered = ref(false);
    const showTooltip = computed(() => viewModel.value.settings.displayValueOnHover && isHovered.value);
    const classes = computed(() => ({
      "--input": props.intf.isInput,
      "--output": !props.intf.isInput,
      "--connected": isConnected.value
    }));
    const showComponent = computed(
      () => props.intf.component && (!props.intf.isInput || !props.intf.port || props.intf.connectionCount === 0)
    );
    const startHover = () => {
      isHovered.value = true;
      hoveredOver(props.intf);
    };
    const endHover = () => {
      isHovered.value = false;
      hoveredOver(void 0);
    };
    const onRender = () => {
      if (el.value) {
        viewModel.value.hooks.renderInterface.execute({ intf: props.intf, el: el.value });
      }
    };
    const openSidebar = () => {
      const sidebar = viewModel.value.displayedGraph.sidebar;
      sidebar.nodeId = props.node.id;
      sidebar.optionName = props.intf.name;
      sidebar.visible = true;
    };
    onMounted(onRender);
    onUpdated(onRender);
    return (_ctx, _cache) => {
      var _a;
      return openBlock(), createElementBlock("div", {
        id: _ctx.intf.id,
        ref_key: "el",
        ref: el,
        class: normalizeClass(["baklava-node-interface", classes.value])
      }, [
        _ctx.intf.port ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["__port", { "--selected": ((_a = unref(temporaryConnection)) == null ? void 0 : _a.from) === _ctx.intf }]),
          onPointerover: startHover,
          onPointerout: endHover
        }, [
          renderSlot(_ctx.$slots, "portTooltip", { showTooltip: showTooltip.value }, () => [
            showTooltip.value === true ? (openBlock(), createElementBlock("span", _hoisted_2$8, toDisplayString(ellipsis(_ctx.intf.value)), 1)) : createCommentVNode("", true)
          ])
        ], 34)) : createCommentVNode("", true),
        showComponent.value ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.intf.component), {
          key: 1,
          modelValue: _ctx.intf.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.intf.value = $event),
          node: _ctx.node,
          intf: _ctx.intf,
          onOpenSidebar: openSidebar
        }, null, 40, ["modelValue", "node", "intf"])) : (openBlock(), createElementBlock("span", _hoisted_3$6, toDisplayString(_ctx.intf.name), 1))
      ], 10, _hoisted_1$q);
    };
  }
});
var _hoisted_1$p = ["id", "data-node-type"];
var _hoisted_2$7 = { class: "__title-label" };
var _hoisted_3$5 = { class: "__menu" };
var _hoisted_4$5 = { class: "__outputs" };
var _hoisted_5$1 = { class: "__inputs" };
var _sfc_main$u = defineComponent({
  __name: "Node",
  props: {
    node: {},
    selected: { type: Boolean, default: false },
    dragging: { type: Boolean }
  },
  emits: ["select", "start-drag"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { viewModel } = useViewModel();
    const { graph, switchGraph } = useGraph();
    const el = ref(null);
    const renaming = ref(false);
    const tempName = ref("");
    const renameInputEl = ref(null);
    const isResizing = ref(false);
    let resizeStartWidth = 0;
    let resizeStartMouseX = 0;
    const showContextMenu = ref(false);
    const contextMenuItems = computed(() => {
      const items = [
        { value: "rename", label: "Rename" },
        { value: "delete", label: "Delete" }
      ];
      if (props.node.type.startsWith(GRAPH_NODE_TYPE_PREFIX)) {
        items.push({ value: "editSubgraph", label: "Edit Subgraph" });
      }
      return items;
    });
    const classes = computed(() => ({
      "--selected": props.selected,
      "--dragging": props.dragging,
      "--two-column": !!props.node.twoColumn
    }));
    const classesContent = computed(() => ({
      "--reverse-y": props.node.reverseY ?? viewModel.value.settings.nodes.reverseY
    }));
    const styles = computed(() => {
      var _a, _b;
      return {
        "top": `${((_a = props.node.position) == null ? void 0 : _a.y) ?? 0}px`,
        "left": `${((_b = props.node.position) == null ? void 0 : _b.x) ?? 0}px`,
        "--width": `${props.node.width ?? viewModel.value.settings.nodes.defaultWidth}px`
      };
    });
    const displayedInputs = computed(() => Object.values(props.node.inputs).filter((ni) => !ni.hidden));
    const displayedOutputs = computed(() => Object.values(props.node.outputs).filter((ni) => !ni.hidden));
    const select = () => {
      emit("select");
    };
    const startDrag = (ev) => {
      if (!props.selected) {
        select();
      }
      emit("start-drag", ev);
    };
    const openContextMenu = () => {
      showContextMenu.value = true;
    };
    const onContextMenuClick = async (action) => {
      var _a;
      switch (action) {
        case "delete":
          graph.value.removeNode(props.node);
          break;
        case "rename":
          tempName.value = props.node.title;
          renaming.value = true;
          await nextTick();
          (_a = renameInputEl.value) == null ? void 0 : _a.focus();
          break;
        case "editSubgraph":
          switchGraph(props.node.template);
          break;
      }
    };
    const doneRenaming = () => {
      props.node.title = tempName.value;
      renaming.value = false;
    };
    const onRender = () => {
      if (el.value) {
        viewModel.value.hooks.renderNode.execute({ node: props.node, el: el.value });
      }
    };
    const startResize = (ev) => {
      isResizing.value = true;
      resizeStartWidth = props.node.width;
      resizeStartMouseX = ev.clientX;
      ev.preventDefault();
    };
    const doResize = (ev) => {
      if (!isResizing.value) return;
      const deltaX = ev.clientX - resizeStartMouseX;
      const newWidth = resizeStartWidth + deltaX / graph.value.scaling;
      const minWidth = viewModel.value.settings.nodes.minWidth;
      const maxWidth = viewModel.value.settings.nodes.maxWidth;
      props.node.width = Math.max(minWidth, Math.min(maxWidth, newWidth));
    };
    const stopResize = () => {
      isResizing.value = false;
    };
    onMounted(() => {
      onRender();
      window.addEventListener("mousemove", doResize);
      window.addEventListener("mouseup", stopResize);
    });
    onUpdated(onRender);
    onBeforeUnmount(() => {
      window.removeEventListener("mousemove", doResize);
      window.removeEventListener("mouseup", stopResize);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        id: _ctx.node.id,
        ref_key: "el",
        ref: el,
        class: normalizeClass(["baklava-node", classes.value]),
        style: normalizeStyle(styles.value),
        "data-node-type": _ctx.node.type,
        onPointerdown: select
      }, [
        unref(viewModel).settings.nodes.resizable ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "__resize-handle",
          onMousedown: startResize
        }, null, 32)) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "title", {}, () => [
          createBaseVNode("div", {
            class: "__title",
            onPointerdown: withModifiers(startDrag, ["self", "stop"]),
            onContextmenu: withModifiers(openContextMenu, ["prevent"])
          }, [
            !renaming.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_2$7, toDisplayString(_ctx.node.title), 1),
              createBaseVNode("div", _hoisted_3$5, [
                createVNode(VerticalDots, {
                  class: "--clickable",
                  onClick: openContextMenu
                }),
                createVNode(unref(_sfc_main$x), {
                  modelValue: showContextMenu.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showContextMenu.value = $event),
                  x: 0,
                  y: 0,
                  items: contextMenuItems.value,
                  onClick: onContextMenuClick
                }, null, 8, ["modelValue", "items"])
              ])
            ], 64)) : withDirectives((openBlock(), createElementBlock("input", {
              key: 1,
              ref_key: "renameInputEl",
              ref: renameInputEl,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => tempName.value = $event),
              type: "text",
              class: "baklava-input",
              placeholder: "Node Name",
              onBlur: doneRenaming,
              onKeydown: withKeys(doneRenaming, ["enter"])
            }, null, 544)), [
              [vModelText, tempName.value]
            ])
          ], 32)
        ]),
        renderSlot(_ctx.$slots, "content", {}, () => [
          createBaseVNode("div", {
            class: normalizeClass(["__content", classesContent.value]),
            onKeydown: _cache[2] || (_cache[2] = withKeys(withModifiers(() => {
            }, ["stop"]), ["delete"]))
          }, [
            createBaseVNode("div", _hoisted_4$5, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(displayedOutputs.value, (output) => {
                return renderSlot(_ctx.$slots, "nodeInterface", {
                  key: output.id,
                  type: "output",
                  node: _ctx.node,
                  intf: output
                }, () => [
                  createVNode(_sfc_main$v, {
                    node: _ctx.node,
                    intf: output
                  }, null, 8, ["node", "intf"])
                ]);
              }), 128))
            ]),
            createBaseVNode("div", _hoisted_5$1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(displayedInputs.value, (input) => {
                return renderSlot(_ctx.$slots, "nodeInterface", {
                  key: input.id,
                  type: "input",
                  node: _ctx.node,
                  intf: input
                }, () => [
                  createVNode(_sfc_main$v, {
                    node: _ctx.node,
                    intf: input
                  }, null, 8, ["node", "intf"])
                ]);
              }), 128))
            ])
          ], 34)
        ])
      ], 46, _hoisted_1$p);
    };
  }
});
var _sfc_main$t = defineComponent({
  props: {
    x1: {
      type: Number,
      required: true
    },
    y1: {
      type: Number,
      required: true
    },
    x2: {
      type: Number,
      required: true
    },
    y2: {
      type: Number,
      required: true
    },
    state: {
      type: Number,
      default: TemporaryConnectionState.NONE
    },
    isTemporary: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const { viewModel } = useViewModel();
    const { graph } = useGraph();
    const transform = (x, y) => {
      const tx = (x + graph.value.panning.x) * graph.value.scaling;
      const ty = (y + graph.value.panning.y) * graph.value.scaling;
      return [tx, ty];
    };
    const d = computed(() => {
      const [tx1, ty1] = transform(props.x1, props.y1);
      const [tx2, ty2] = transform(props.x2, props.y2);
      if (viewModel.value.settings.useStraightConnections) {
        return `M ${tx1} ${ty1} L ${tx2} ${ty2}`;
      } else {
        const dx = 0.3 * Math.abs(tx1 - tx2);
        return `M ${tx1} ${ty1} C ${tx1 + dx} ${ty1}, ${tx2 - dx} ${ty2}, ${tx2} ${ty2}`;
      }
    });
    const classes = computed(() => ({
      "--temporary": props.isTemporary,
      "--allowed": props.state === TemporaryConnectionState.ALLOWED,
      "--forbidden": props.state === TemporaryConnectionState.FORBIDDEN
    }));
    return { d, classes };
  }
});
var _hoisted_1$o = ["d"];
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("path", {
    class: normalizeClass(["baklava-connection", _ctx.classes]),
    d: _ctx.d
  }, null, 10, _hoisted_1$o);
}
var ConnectionView = _export_sfc(_sfc_main$t, [["render", _sfc_render$n]]);
function getDomElementOfNode(node) {
  return document.getElementById(node.id);
}
function getDomElements(ni) {
  const interfaceDOM = document.getElementById(ni.id);
  const portDOM = interfaceDOM == null ? void 0 : interfaceDOM.getElementsByClassName("__port");
  return {
    node: (interfaceDOM == null ? void 0 : interfaceDOM.closest(".baklava-node")) ?? null,
    interface: interfaceDOM,
    port: portDOM && portDOM.length > 0 ? portDOM[0] : null
  };
}
var _sfc_main$s = defineComponent({
  components: {
    "connection-view": ConnectionView
  },
  props: {
    connection: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const { graph } = useGraph();
    let resizeObserver;
    const d = ref({ x1: 0, y1: 0, x2: 0, y2: 0 });
    const state = computed(
      () => props.connection.isInDanger ? TemporaryConnectionState.FORBIDDEN : TemporaryConnectionState.NONE
    );
    const fromNodePosition = computed(() => {
      var _a;
      return (_a = graph.value.findNodeById(props.connection.from.nodeId)) == null ? void 0 : _a.position;
    });
    const toNodePosition = computed(() => {
      var _a;
      return (_a = graph.value.findNodeById(props.connection.to.nodeId)) == null ? void 0 : _a.position;
    });
    const getPortCoordinates2 = (resolved) => {
      if (resolved.node && resolved.interface && resolved.port) {
        return [
          resolved.node.offsetLeft + resolved.interface.offsetLeft + resolved.port.offsetLeft + resolved.port.clientWidth / 2,
          resolved.node.offsetTop + resolved.interface.offsetTop + resolved.port.offsetTop + resolved.port.clientHeight / 2
        ];
      } else {
        return [0, 0];
      }
    };
    const updateCoords = () => {
      const from = getDomElements(props.connection.from);
      const to = getDomElements(props.connection.to);
      if (from.node && to.node) {
        if (!resizeObserver) {
          resizeObserver = new ResizeObserver(() => {
            updateCoords();
          });
          resizeObserver.observe(from.node);
          resizeObserver.observe(to.node);
        }
      }
      const [x1, y1] = getPortCoordinates2(from);
      const [x2, y2] = getPortCoordinates2(to);
      d.value = { x1, y1, x2, y2 };
    };
    onMounted(async () => {
      await nextTick();
      updateCoords();
    });
    onBeforeUnmount(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    });
    watch([fromNodePosition, toNodePosition], () => updateCoords(), { deep: true });
    return { d, state };
  }
});
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_connection_view = resolveComponent("connection-view");
  return openBlock(), createBlock(_component_connection_view, {
    x1: _ctx.d.x1,
    y1: _ctx.d.y1,
    x2: _ctx.d.x2,
    y2: _ctx.d.y2,
    state: _ctx.state
  }, null, 8, ["x1", "y1", "x2", "y2", "state"]);
}
var ConnectionWrapper = _export_sfc(_sfc_main$s, [["render", _sfc_render$m]]);
function getPortCoordinates(resolved) {
  if (resolved.node && resolved.interface && resolved.port) {
    return [
      resolved.node.offsetLeft + resolved.interface.offsetLeft + resolved.port.offsetLeft + resolved.port.clientWidth / 2,
      resolved.node.offsetTop + resolved.interface.offsetTop + resolved.port.offsetTop + resolved.port.clientHeight / 2
    ];
  } else {
    return [0, 0];
  }
}
var _sfc_main$r = defineComponent({
  components: {
    "connection-view": ConnectionView
  },
  props: {
    connection: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const status = computed(() => props.connection ? props.connection.status : TemporaryConnectionState.NONE);
    const d = computed(() => {
      if (!props.connection) {
        return {
          input: [0, 0],
          output: [0, 0]
        };
      }
      const start = getPortCoordinates(getDomElements(props.connection.from));
      const end = props.connection.to ? getPortCoordinates(getDomElements(props.connection.to)) : [props.connection.mx || start[0], props.connection.my || start[1]];
      if (props.connection.from.isInput) {
        return {
          input: end,
          output: start
        };
      } else {
        return {
          input: start,
          output: end
        };
      }
    });
    return { d, status };
  }
});
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_connection_view = resolveComponent("connection-view");
  return openBlock(), createBlock(_component_connection_view, {
    x1: _ctx.d.input[0],
    y1: _ctx.d.input[1],
    x2: _ctx.d.output[0],
    y2: _ctx.d.output[1],
    state: _ctx.status,
    "is-temporary": ""
  }, null, 8, ["x1", "y1", "x2", "y2", "state"]);
}
var TemporaryConnection = _export_sfc(_sfc_main$r, [["render", _sfc_render$l]]);
var _sfc_main$q = defineComponent({
  setup() {
    const { viewModel } = useViewModel();
    const { graph } = useGraph();
    const el = ref(null);
    const width = toRef(viewModel.value.settings.sidebar, "width");
    const resizable = computed(() => viewModel.value.settings.sidebar.resizable);
    let resizeStartWidth = 0;
    let resizeStartMouseX = 0;
    const node = computed(() => {
      const id = graph.value.sidebar.nodeId;
      return graph.value.nodes.find((x) => x.id === id);
    });
    const styles = computed(() => ({
      width: `${width.value}px`
    }));
    const displayedInterfaces = computed(() => {
      if (!node.value) {
        return [];
      }
      const allIntfs = [...Object.values(node.value.inputs), ...Object.values(node.value.outputs)];
      return allIntfs.filter((intf) => intf.displayInSidebar && intf.component);
    });
    const close = () => {
      graph.value.sidebar.visible = false;
    };
    const startResize = (event) => {
      resizeStartWidth = width.value;
      resizeStartMouseX = event.clientX;
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener(
        "mouseup",
        () => {
          window.removeEventListener("mousemove", onMouseMove);
        },
        { once: true }
      );
    };
    const onMouseMove = (event) => {
      var _a, _b;
      const maxwidth = ((_b = (_a = el.value) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.getBoundingClientRect().width) ?? 500;
      const deltaX = event.clientX - resizeStartMouseX;
      let newWidth = resizeStartWidth - deltaX;
      if (newWidth < 300) {
        newWidth = 300;
      } else if (newWidth > 0.9 * maxwidth) {
        newWidth = 0.9 * maxwidth;
      }
      width.value = newWidth;
    };
    return { el, graph, resizable, node, styles, displayedInterfaces, startResize, close };
  }
});
var _hoisted_1$n = { class: "__header" };
var _hoisted_2$6 = { class: "__node-name" };
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "el",
    class: normalizeClass(["baklava-sidebar", { "--open": _ctx.graph.sidebar.visible }]),
    style: normalizeStyle(_ctx.styles)
  }, [
    _ctx.resizable ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "__resizer",
      onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.startResize && _ctx.startResize(...args))
    }, null, 32)) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_1$n, [
      createBaseVNode("button", {
        tabindex: "-1",
        class: "__close",
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.close && _ctx.close(...args))
      }, "×"),
      createBaseVNode("div", _hoisted_2$6, [
        createBaseVNode("b", null, toDisplayString(_ctx.node ? _ctx.node.title : ""), 1)
      ])
    ]),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.displayedInterfaces, (intf) => {
      return openBlock(), createElementBlock("div", {
        key: intf.id,
        class: "__interface"
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(intf.component), {
          modelValue: intf.value,
          "onUpdate:modelValue": ($event) => intf.value = $event,
          node: _ctx.node,
          intf
        }, null, 8, ["modelValue", "onUpdate:modelValue", "node", "intf"]))
      ]);
    }), 128))
  ], 6);
}
var Sidebar = _export_sfc(_sfc_main$q, [["render", _sfc_render$k]]);
var _sfc_main$p = defineComponent({
  __name: "Minimap",
  setup(__props) {
    const { viewModel } = useViewModel();
    const { graph } = useGraph();
    const canvas = ref(null);
    const showViewBounds = ref(false);
    let ctx;
    let dragging = false;
    let bounds = { x1: 0, y1: 0, x2: 0, y2: 0 };
    let interval;
    const updateCanvas = () => {
      var _a, _b;
      if (!ctx) {
        return;
      }
      ctx.canvas.width = canvas.value.offsetWidth;
      ctx.canvas.height = canvas.value.offsetHeight;
      const nodeCoords = /* @__PURE__ */ new Map();
      const nodeDomElements = /* @__PURE__ */ new Map();
      for (const n of graph.value.nodes) {
        const domElement = getDomElementOfNode(n);
        const width = (domElement == null ? void 0 : domElement.offsetWidth) ?? 0;
        const height = (domElement == null ? void 0 : domElement.offsetHeight) ?? 0;
        const posX = ((_a = n.position) == null ? void 0 : _a.x) ?? 0;
        const posY = ((_b = n.position) == null ? void 0 : _b.y) ?? 0;
        nodeCoords.set(n, {
          x1: posX,
          y1: posY,
          x2: posX + width,
          y2: posY + height
        });
        nodeDomElements.set(n, domElement);
      }
      const newBounds = {
        x1: Number.MAX_SAFE_INTEGER,
        y1: Number.MAX_SAFE_INTEGER,
        x2: Number.MIN_SAFE_INTEGER,
        y2: Number.MIN_SAFE_INTEGER
      };
      for (const nc of nodeCoords.values()) {
        if (nc.x1 < newBounds.x1) {
          newBounds.x1 = nc.x1;
        }
        if (nc.y1 < newBounds.y1) {
          newBounds.y1 = nc.y1;
        }
        if (nc.x2 > newBounds.x2) {
          newBounds.x2 = nc.x2;
        }
        if (nc.y2 > newBounds.y2) {
          newBounds.y2 = nc.y2;
        }
      }
      const padding = 50;
      newBounds.x1 -= padding;
      newBounds.y1 -= padding;
      newBounds.x2 += padding;
      newBounds.y2 += padding;
      bounds = newBounds;
      const canvasRatio = ctx.canvas.width / ctx.canvas.height;
      const boundsRatio = (bounds.x2 - bounds.x1) / (bounds.y2 - bounds.y1);
      if (canvasRatio > boundsRatio) {
        const diff = (canvasRatio - boundsRatio) * (bounds.y2 - bounds.y1) * 0.5;
        bounds.x1 -= diff;
        bounds.x2 += diff;
      } else {
        const boundsWidth = bounds.x2 - bounds.x1;
        const boundsHeight = bounds.y2 - bounds.y1;
        const diff = (boundsWidth - canvasRatio * boundsHeight) / canvasRatio * 0.5;
        bounds.y1 -= diff;
        bounds.y2 += diff;
      }
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.strokeStyle = "white";
      for (const c of graph.value.connections) {
        const [origX1, origY1] = getPortCoordinates(getDomElements(c.from));
        const [origX2, origY2] = getPortCoordinates(getDomElements(c.to));
        const [x1, y1] = transformCoordinates(origX1, origY1);
        const [x2, y2] = transformCoordinates(origX2, origY2);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        if (viewModel.value.settings.useStraightConnections) {
          ctx.lineTo(x2, y2);
        } else {
          const dx = 0.3 * Math.abs(x1 - x2);
          ctx.bezierCurveTo(x1 + dx, y1, x2 - dx, y2, x2, y2);
        }
        ctx.stroke();
      }
      ctx.strokeStyle = "lightgray";
      for (const [n, nc] of nodeCoords.entries()) {
        const [x1, y1] = transformCoordinates(nc.x1, nc.y1);
        const [x2, y2] = transformCoordinates(nc.x2, nc.y2);
        ctx.fillStyle = getNodeColor(nodeDomElements.get(n));
        ctx.beginPath();
        ctx.rect(x1, y1, x2 - x1, y2 - y1);
        ctx.fill();
        ctx.stroke();
      }
      if (showViewBounds.value) {
        const viewBounds = getViewBounds();
        const [x1, y1] = transformCoordinates(viewBounds.x1, viewBounds.y1);
        const [x2, y2] = transformCoordinates(viewBounds.x2, viewBounds.y2);
        ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
        ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
      }
    };
    const transformCoordinates = (origX, origY) => {
      return [
        (origX - bounds.x1) / (bounds.x2 - bounds.x1) * ctx.canvas.width,
        (origY - bounds.y1) / (bounds.y2 - bounds.y1) * ctx.canvas.height
      ];
    };
    const reverseTransform = (thisX, thisY) => {
      return [
        thisX * (bounds.x2 - bounds.x1) / ctx.canvas.width + bounds.x1,
        thisY * (bounds.y2 - bounds.y1) / ctx.canvas.height + bounds.y1
      ];
    };
    const getNodeColor = (domElement) => {
      if (domElement) {
        const content = domElement.querySelector(".__content");
        if (content) {
          const contentColor = getComputedColor(content);
          if (contentColor) {
            return contentColor;
          }
        }
        const nodeColor = getComputedColor(domElement);
        if (nodeColor) {
          return nodeColor;
        }
      }
      return "gray";
    };
    const getComputedColor = (domElement) => {
      const c = getComputedStyle(domElement).backgroundColor;
      if (c && c !== "rgba(0, 0, 0, 0)") {
        return c;
      }
    };
    const getViewBounds = () => {
      const parentWidth = canvas.value.parentElement.offsetWidth;
      const parentHeight = canvas.value.parentElement.offsetHeight;
      const x2 = parentWidth / graph.value.scaling - graph.value.panning.x;
      const y2 = parentHeight / graph.value.scaling - graph.value.panning.y;
      return { x1: -graph.value.panning.x, y1: -graph.value.panning.y, x2, y2 };
    };
    const mousedown = (ev) => {
      if (ev.button === 0) {
        dragging = true;
        mousemove(ev);
      }
    };
    const mousemove = (ev) => {
      if (dragging) {
        const [cx, cy] = reverseTransform(ev.offsetX, ev.offsetY);
        const viewBounds = getViewBounds();
        const dx = (viewBounds.x2 - viewBounds.x1) / 2;
        const dy = (viewBounds.y2 - viewBounds.y1) / 2;
        graph.value.panning.x = -(cx - dx);
        graph.value.panning.y = -(cy - dy);
      }
    };
    const mouseup = () => {
      dragging = false;
    };
    const mouseenter = () => {
      showViewBounds.value = true;
    };
    const mouseleave = () => {
      showViewBounds.value = false;
      mouseup();
    };
    watch([showViewBounds, graph.value.panning, () => graph.value.scaling, () => graph.value.connections.length], () => {
      updateCanvas();
    });
    const nodePositions = computed(() => graph.value.nodes.map((n) => n.position));
    const nodeSizes = computed(() => graph.value.nodes.map((n) => n.width));
    watch(
      [nodePositions, nodeSizes],
      () => {
        updateCanvas();
      },
      { deep: true }
    );
    onMounted(() => {
      ctx = canvas.value.getContext("2d");
      ctx.imageSmoothingQuality = "high";
      updateCanvas();
      interval = setInterval(updateCanvas, 500);
    });
    onBeforeUnmount(() => {
      clearInterval(interval);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("canvas", {
        ref_key: "canvas",
        ref: canvas,
        class: "baklava-minimap",
        onMouseenter: mouseenter,
        onMouseleave: mouseleave,
        onMousedown: withModifiers(mousedown, ["self"]),
        onMousemove: withModifiers(mousemove, ["self"]),
        onMouseup: mouseup,
        onContextmenu: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["stop", "prevent"]))
      }, null, 544);
    };
  }
});
var _sfc_main$o = defineComponent({
  components: { ContextMenu: _sfc_main$x, VerticalDots },
  props: {
    type: {
      type: String,
      required: true
    },
    title: {
      type: String,
      required: true
    }
  },
  setup(props) {
    const { viewModel } = useViewModel();
    const { switchGraph } = useGraph();
    const showContextMenu = ref(false);
    const hasContextMenu = computed(() => props.type.startsWith(GRAPH_NODE_TYPE_PREFIX));
    const contextMenuItems = [
      { label: "Edit Subgraph", value: "editSubgraph" },
      { label: "Delete Subgraph", value: "deleteSubgraph" }
    ];
    const openContextMenu = () => {
      showContextMenu.value = true;
    };
    const onContextMenuClick = (action) => {
      const graphTemplateId = props.type.substring(GRAPH_NODE_TYPE_PREFIX.length);
      const graphTemplate = viewModel.value.editor.graphTemplates.find((gt) => gt.id === graphTemplateId);
      if (!graphTemplate) {
        return;
      }
      switch (action) {
        case "editSubgraph":
          switchGraph(graphTemplate);
          break;
        case "deleteSubgraph":
          viewModel.value.editor.removeGraphTemplate(graphTemplate);
          break;
      }
    };
    return { showContextMenu, hasContextMenu, contextMenuItems, openContextMenu, onContextMenuClick };
  }
});
var _hoisted_1$m = ["data-node-type"];
var _hoisted_2$5 = { class: "__title" };
var _hoisted_3$4 = { class: "__title-label" };
var _hoisted_4$4 = {
  key: 0,
  class: "__menu"
};
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_vertical_dots = resolveComponent("vertical-dots");
  const _component_context_menu = resolveComponent("context-menu");
  return openBlock(), createElementBlock("div", {
    class: "baklava-node --palette",
    "data-node-type": _ctx.type
  }, [
    createBaseVNode("div", _hoisted_2$5, [
      createBaseVNode("div", _hoisted_3$4, toDisplayString(_ctx.title), 1),
      _ctx.hasContextMenu ? (openBlock(), createElementBlock("div", _hoisted_4$4, [
        createVNode(_component_vertical_dots, {
          class: "--clickable",
          onPointerdown: _cache[0] || (_cache[0] = withModifiers(() => {
          }, ["stop", "prevent"])),
          onClick: withModifiers(_ctx.openContextMenu, ["stop", "prevent"])
        }, null, 8, ["onClick"]),
        createVNode(_component_context_menu, {
          modelValue: _ctx.showContextMenu,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.showContextMenu = $event),
          x: -100,
          y: 0,
          items: _ctx.contextMenuItems,
          onClick: _ctx.onContextMenuClick,
          onPointerdown: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop", "prevent"]))
        }, null, 8, ["modelValue", "items", "onClick"])
      ])) : createCommentVNode("", true)
    ])
  ], 8, _hoisted_1$m);
}
var PaletteEntry = _export_sfc(_sfc_main$o, [["render", _sfc_render$j]]);
var _hoisted_1$l = { key: 0 };
var _sfc_main$n = defineComponent({
  __name: "NodePalette",
  setup(__props) {
    const { viewModel } = useViewModel();
    const { x: mouseX, y: mouseY } = usePointer();
    const { transform } = useTransform();
    const categories = useNodeCategories(viewModel);
    const editorEl = inject("editorEl");
    const draggedNode = ref(null);
    const draggedNodeStyles = computed(() => {
      if (!draggedNode.value || !(editorEl == null ? void 0 : editorEl.value)) {
        return {};
      }
      const { left, top } = editorEl.value.getBoundingClientRect();
      return {
        top: `${mouseY.value - top}px`,
        left: `${mouseX.value - left}px`
      };
    });
    const onDragStart = (type, nodeInformation) => {
      draggedNode.value = {
        type,
        nodeInformation
      };
      const onDragEnd = () => {
        const instance = reactive(new nodeInformation.type());
        viewModel.value.displayedGraph.addNode(instance);
        const rect = editorEl.value.getBoundingClientRect();
        const [x, y] = transform(mouseX.value - rect.left, mouseY.value - rect.top);
        instance.position.x = x;
        instance.position.y = y;
        draggedNode.value = null;
        document.removeEventListener("pointerup", onDragEnd);
      };
      document.addEventListener("pointerup", onDragEnd);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", {
          class: "baklava-node-palette",
          onContextmenu: _cache[0] || (_cache[0] = withModifiers(() => {
          }, ["stop", "prevent"]))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(categories), (c) => {
            return openBlock(), createElementBlock("section", {
              key: c.name
            }, [
              c.name !== "default" ? (openBlock(), createElementBlock("h1", _hoisted_1$l, toDisplayString(c.name), 1)) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(c.nodeTypes, (ni, nt) => {
                return openBlock(), createBlock(PaletteEntry, {
                  key: nt,
                  type: nt,
                  title: ni.title,
                  onPointerdown: ($event) => onDragStart(nt, ni)
                }, null, 8, ["type", "title", "onPointerdown"]);
              }), 128))
            ]);
          }), 128))
        ], 32),
        createVNode(Transition, { name: "fade" }, {
          default: withCtx(() => [
            draggedNode.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "baklava-dragged-node",
              style: normalizeStyle(draggedNodeStyles.value)
            }, [
              createVNode(PaletteEntry, {
                type: draggedNode.value.type,
                title: draggedNode.value.nodeInformation.title
              }, null, 8, ["type", "title"])
            ], 4)) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ], 64);
    };
  }
});
var _sfc_main$m = defineComponent({
  props: {
    command: {
      type: String,
      required: true
    },
    title: {
      type: String,
      required: true
    },
    icon: {
      type: Object,
      required: false,
      default: void 0
    }
  },
  setup() {
    const { viewModel } = useViewModel();
    return { viewModel };
  }
});
var _hoisted_1$k = ["disabled", "title"];
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    class: "baklava-toolbar-entry baklava-toolbar-button",
    disabled: !_ctx.viewModel.commandHandler.canExecuteCommand(_ctx.command),
    title: _ctx.title,
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.viewModel.commandHandler.executeCommand(_ctx.command))
  }, [
    _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      createTextVNode(toDisplayString(_ctx.title), 1)
    ], 64))
  ], 8, _hoisted_1$k);
}
var ToolbarButton = _export_sfc(_sfc_main$m, [["render", _sfc_render$i]]);
var _sfc_main$l = defineComponent({
  __name: "Toolbar",
  setup(__props) {
    const { viewModel } = useViewModel();
    const isSubgraph = computed(() => viewModel.value.displayedGraph !== viewModel.value.editor.graph);
    const commands = computed(() => viewModel.value.settings.toolbar.commands);
    const subgraphCommands = computed(() => viewModel.value.settings.toolbar.subgraphCommands);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "baklava-toolbar",
        onContextmenu: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["stop", "prevent"]))
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(commands.value, (c) => {
          return openBlock(), createBlock(ToolbarButton, {
            key: c.command,
            command: c.command,
            title: c.title,
            icon: c.icon
          }, null, 8, ["command", "title", "icon"]);
        }), 128)),
        isSubgraph.value ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(subgraphCommands.value, (c) => {
          return openBlock(), createBlock(ToolbarButton, {
            key: c.command,
            command: c.command,
            title: c.title,
            icon: c.icon
          }, null, 8, ["command", "title", "icon"]);
        }), 128)) : createCommentVNode("", true)
      ], 32);
    };
  }
});
var _hoisted_1$j = { class: "connections-container" };
var _sfc_main$k = defineComponent({
  __name: "Editor",
  props: {
    viewModel: {}
  },
  setup(__props) {
    const props = __props;
    const token = Symbol("EditorToken");
    const viewModelRef2 = toRef(props, "viewModel");
    providePlugin(viewModelRef2);
    const el = ref(null);
    provide("editorEl", el);
    const nodes = computed(() => props.viewModel.displayedGraph.nodes);
    const dragMoves = computed(() => props.viewModel.displayedGraph.nodes.map((n) => useDragMove(toRef(n, "position"))));
    const connections = computed(() => props.viewModel.displayedGraph.connections);
    const selectedNodes = computed(() => props.viewModel.displayedGraph.selectedNodes);
    const panZoom = usePanZoom();
    const temporaryConnection = provideTemporaryConnection();
    const contextMenu = useContextMenu(viewModelRef2);
    const selectionBox = useSelectionBox(el);
    const nodeContainerStyle = computed(() => ({
      ...panZoom.styles.value
    }));
    const counter = ref(0);
    props.viewModel.editor.hooks.load.subscribe(token, (s) => {
      counter.value++;
      return s;
    });
    const onPointerMove = (ev) => {
      panZoom.onPointerMove(ev);
      temporaryConnection.onMouseMove(ev);
    };
    const onPointerDown = (ev) => {
      if (ev.button === 0) {
        if (selectionBox.onPointerDown(ev)) {
          return;
        }
        if (ev.target === el.value) {
          unselectAllNodes();
          panZoom.onPointerDown(ev);
        }
        temporaryConnection.onMouseDown();
      }
    };
    const onPointerUp = (ev) => {
      panZoom.onPointerUp(ev);
      temporaryConnection.onMouseUp();
    };
    const keyDown = (ev) => {
      if (ev.key === "Tab") {
        ev.preventDefault();
      }
      props.viewModel.commandHandler.handleKeyDown(ev);
    };
    const keyUp = (ev) => {
      props.viewModel.commandHandler.handleKeyUp(ev);
    };
    const selectNode = (node) => {
      if (!["Control", "Shift"].some((k) => props.viewModel.commandHandler.pressedKeys.includes(k))) {
        unselectAllNodes();
      }
      props.viewModel.displayedGraph.selectedNodes.push(node);
    };
    const unselectAllNodes = () => {
      props.viewModel.displayedGraph.selectedNodes = [];
    };
    const startDrag = (ev) => {
      for (const selectedNode of props.viewModel.displayedGraph.selectedNodes) {
        const idx = nodes.value.indexOf(selectedNode);
        const dragMove = dragMoves.value[idx];
        dragMove.onPointerDown(ev);
        document.addEventListener("pointermove", dragMove.onPointerMove);
      }
      document.addEventListener("pointerup", stopDrag);
    };
    const stopDrag = () => {
      for (const selectedNode of props.viewModel.displayedGraph.selectedNodes) {
        const idx = nodes.value.indexOf(selectedNode);
        const dragMove = dragMoves.value[idx];
        dragMove.onPointerUp();
        document.removeEventListener("pointermove", dragMove.onPointerMove);
      }
      document.removeEventListener("pointerup", stopDrag);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "el",
        ref: el,
        tabindex: "-1",
        class: normalizeClass(["baklava-editor", {
          "baklava-ignore-mouse": !!unref(temporaryConnection).temporaryConnection.value || unref(panZoom).dragging.value,
          "--temporary-connection": !!unref(temporaryConnection).temporaryConnection.value,
          "--start-selection-box": unref(selectionBox).startSelection
        }]),
        onPointermove: withModifiers(onPointerMove, ["self"]),
        onPointerdown: onPointerDown,
        onPointerup: onPointerUp,
        onWheel: _cache[1] || (_cache[1] = withModifiers(
          //@ts-ignore
          (...args) => unref(panZoom).onMouseWheel && unref(panZoom).onMouseWheel(...args),
          ["self"]
        )),
        onKeydown: keyDown,
        onKeyup: keyUp,
        onContextmenu: _cache[2] || (_cache[2] = withModifiers(
          //@ts-ignore
          (...args) => unref(contextMenu).open && unref(contextMenu).open(...args),
          ["self"]
        ))
      }, [
        renderSlot(_ctx.$slots, "background", {}, () => [
          createVNode(Background)
        ]),
        renderSlot(_ctx.$slots, "toolbar", {}, () => [
          _ctx.viewModel.settings.toolbar.enabled ? (openBlock(), createBlock(_sfc_main$l, { key: 0 })) : createCommentVNode("", true)
        ]),
        renderSlot(_ctx.$slots, "palette", {}, () => [
          _ctx.viewModel.settings.palette.enabled ? (openBlock(), createBlock(_sfc_main$n, { key: 0 })) : createCommentVNode("", true)
        ]),
        (openBlock(), createElementBlock("svg", _hoisted_1$j, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(connections.value, (connection) => {
            return openBlock(), createElementBlock("g", {
              key: connection.id + counter.value.toString()
            }, [
              renderSlot(_ctx.$slots, "connection", { connection }, () => [
                createVNode(ConnectionWrapper, { connection }, null, 8, ["connection"])
              ])
            ]);
          }), 128)),
          renderSlot(_ctx.$slots, "temporaryConnection", {
            temporaryConnection: unref(temporaryConnection).temporaryConnection.value
          }, () => [
            unref(temporaryConnection).temporaryConnection.value ? (openBlock(), createBlock(TemporaryConnection, {
              key: 0,
              connection: unref(temporaryConnection).temporaryConnection.value
            }, null, 8, ["connection"])) : createCommentVNode("", true)
          ])
        ])),
        createBaseVNode("div", {
          class: "node-container",
          style: normalizeStyle(nodeContainerStyle.value)
        }, [
          createVNode(TransitionGroup, { name: "fade" }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(nodes.value, (node, idx) => {
                return renderSlot(_ctx.$slots, "node", {
                  key: node.id + counter.value.toString(),
                  node,
                  selected: selectedNodes.value.includes(node),
                  dragging: dragMoves.value[idx].dragging.value,
                  onSelect: ($event) => selectNode(node),
                  onStartDrag: startDrag
                }, () => [
                  createVNode(_sfc_main$u, {
                    node,
                    selected: selectedNodes.value.includes(node),
                    dragging: dragMoves.value[idx].dragging.value,
                    onSelect: ($event) => selectNode(node),
                    onStartDrag: startDrag
                  }, null, 8, ["node", "selected", "dragging", "onSelect"])
                ]);
              }), 128))
            ]),
            _: 3
          })
        ], 4),
        renderSlot(_ctx.$slots, "sidebar", {}, () => [
          _ctx.viewModel.settings.sidebar.enabled ? (openBlock(), createBlock(Sidebar, { key: 0 })) : createCommentVNode("", true)
        ]),
        renderSlot(_ctx.$slots, "minimap", {}, () => [
          _ctx.viewModel.settings.enableMinimap ? (openBlock(), createBlock(_sfc_main$p, { key: 0 })) : createCommentVNode("", true)
        ]),
        renderSlot(_ctx.$slots, "contextMenu", { contextMenu: unref(contextMenu) }, () => [
          _ctx.viewModel.settings.contextMenu.enabled ? (openBlock(), createBlock(_sfc_main$x, {
            key: 0,
            modelValue: unref(contextMenu).show.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(contextMenu).show.value = $event),
            items: unref(contextMenu).items.value,
            x: unref(contextMenu).x.value,
            y: unref(contextMenu).y.value,
            onClick: unref(contextMenu).onClick
          }, null, 8, ["modelValue", "items", "x", "y", "onClick"])) : createCommentVNode("", true)
        ]),
        unref(selectionBox).isSelecting ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "selection-box",
          style: normalizeStyle(unref(selectionBox).getStyles())
        }, null, 4)) : createCommentVNode("", true)
      ], 34);
    };
  }
});
function useHotkeyHandler(executeCommand) {
  const pressedKeys = ref([]);
  const handlers = ref([]);
  const handleKeyDown = (ev) => {
    if (!pressedKeys.value.includes(ev.key)) {
      pressedKeys.value.push(ev.key);
    }
    if (document.activeElement && isInputElement(document.activeElement)) {
      return;
    }
    handlers.value.forEach((h) => {
      var _a, _b;
      if (h.keys.every((k) => pressedKeys.value.includes(k))) {
        if ((_a = h.options) == null ? void 0 : _a.preventDefault) {
          ev.preventDefault();
        }
        if ((_b = h.options) == null ? void 0 : _b.stopPropagation) {
          ev.stopPropagation();
        }
        executeCommand(h.commandName);
      }
    });
  };
  const handleKeyUp = (ev) => {
    const index = pressedKeys.value.indexOf(ev.key);
    if (index >= 0) {
      pressedKeys.value.splice(index, 1);
    }
  };
  const registerHotkey = (keys2, commandName, options) => {
    handlers.value.push({ keys: keys2, commandName, options });
  };
  return { pressedKeys, handleKeyDown, handleKeyUp, registerHotkey };
}
var useCommandHandler = () => {
  const commands = ref(/* @__PURE__ */ new Map());
  const hasCommand = (name) => commands.value.has(name);
  const registerCommand = (name, command) => {
    if (commands.value.has(name)) {
      throw new Error(`Command "${name}" already exists`);
    }
    commands.value.set(name, command);
  };
  const executeCommand = (name, throwOnNonexisting = false, ...args) => {
    if (!commands.value.has(name)) {
      if (throwOnNonexisting) {
        throw new Error(`[CommandHandler] Command ${name} not registered`);
      } else {
        return;
      }
    }
    return commands.value.get(name).execute(...args);
  };
  const canExecuteCommand = (name, throwOnNonexisting = false, ...args) => {
    if (!commands.value.has(name)) {
      if (throwOnNonexisting) {
        throw new Error(`[CommandHandler] Command ${name} not registered`);
      } else {
        return false;
      }
    }
    return commands.value.get(name).canExecute(args);
  };
  const hotkeyHandler = useHotkeyHandler(executeCommand);
  return reactive({ hasCommand, registerCommand, executeCommand, canExecuteCommand, ...hotkeyHandler });
};
var _sfc_main$j = defineComponent({
  props: {
    intf: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const onClick = () => {
      if (props.intf.callback) {
        props.intf.callback();
      }
    };
    return { onClick };
  }
});
var _hoisted_1$i = ["title"];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    class: "baklava-button --block",
    title: _ctx.intf.name,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, toDisplayString(_ctx.intf.name), 9, _hoisted_1$i);
}
var ButtonInterfaceComponent = _export_sfc(_sfc_main$j, [["render", _sfc_render$h]]);
var ButtonInterface = class extends NodeInterface {
  constructor(name, callback) {
    super(name, void 0);
    this.component = markRaw(ButtonInterfaceComponent);
    this.callback = callback;
    this.setPort(false);
  }
};
var _hoisted_1$h = ["title"];
var _hoisted_2$4 = { class: "__label" };
var _sfc_main$i = defineComponent({
  __name: "CheckboxInterface",
  props: {
    modelValue: { type: Boolean },
    intf: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["baklava-checkbox", { "--checked": _ctx.modelValue }]),
        title: _ctx.intf.name,
        onClick: _cache[0] || (_cache[0] = ($event) => emit("update:modelValue", !_ctx.modelValue))
      }, [
        _cache[1] || (_cache[1] = createBaseVNode("div", { class: "__checkmark-container" }, [
          createBaseVNode("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            width: "18",
            height: "18",
            viewBox: "0 0 18 18"
          }, [
            createBaseVNode("path", {
              class: "__checkmark",
              d: "M 6 5 L 6 10 L 16 10",
              transform: "rotate(-45 10 10)"
            })
          ])
        ], -1)),
        createBaseVNode("div", _hoisted_2$4, toDisplayString(_ctx.intf.name), 1)
      ], 10, _hoisted_1$h);
    };
  }
});
var CheckboxInterface = class extends NodeInterface {
  constructor() {
    super(...arguments);
    this.component = markRaw(_sfc_main$i);
  }
};
var MAX_STRING_LENGTH = 9;
function isValidator(intf) {
  return "validate" in intf;
}
var BaseNumericInterface = class extends NodeInterface {
  constructor(name, value, min, max) {
    super(name, value);
    this.min = min;
    this.max = max;
  }
  validate(v) {
    return (this.min === void 0 || v >= this.min) && (this.max === void 0 || v <= this.max);
  }
};
var useBaseNumericInterface = (intf, precision = 3) => {
  const inputEl = ref(null);
  const editMode = ref(false);
  const invalid = ref(false);
  const tempValue = ref("0");
  const stringRepresentation = computed(() => {
    const s = intf.value.value.toFixed(precision);
    return s.length > MAX_STRING_LENGTH ? intf.value.value.toExponential(MAX_STRING_LENGTH - 5) : s;
  });
  const validate = (v) => {
    if (Number.isNaN(v)) {
      return false;
    } else if (isValidator(intf.value)) {
      return intf.value.validate(v);
    } else {
      return true;
    }
  };
  const setValue = (newValue) => {
    if (validate(newValue)) {
      intf.value.value = newValue;
    }
  };
  watch(tempValue, () => {
    invalid.value = false;
  });
  const enterEditMode = async () => {
    tempValue.value = intf.value.value.toFixed(precision);
    editMode.value = true;
    await nextTick();
    if (inputEl.value) {
      inputEl.value.focus();
    }
  };
  const leaveEditMode = () => {
    const v = parseFloat(tempValue.value);
    if (!validate(v)) {
      invalid.value = true;
    } else {
      setValue(v);
      editMode.value = false;
    }
  };
  return {
    editMode,
    invalid,
    tempValue,
    inputEl,
    stringRepresentation,
    validate,
    setValue,
    enterEditMode,
    leaveEditMode
  };
};
var _sfc_main$h = {};
var _hoisted_1$g = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "baklava-icon",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  "stroke-width": "2",
  stroke: "currentColor",
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _sfc_render$g(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$g, _cache[0] || (_cache[0] = [
    createBaseVNode("polyline", { points: "6 9 12 15 18 9" }, null, -1)
  ]));
}
var Arrow = _export_sfc(_sfc_main$h, [["render", _sfc_render$g]]);
var _sfc_main$g = defineComponent({
  components: {
    "i-arrow": Arrow
  },
  props: {
    intf: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const baseNumericInterface = useBaseNumericInterface(toRef(props, "intf"), 0);
    const increment = () => {
      baseNumericInterface.setValue(props.intf.value + 1);
    };
    const decrement = () => {
      baseNumericInterface.setValue(props.intf.value - 1);
    };
    return { ...baseNumericInterface, increment, decrement };
  }
});
var _hoisted_1$f = { class: "baklava-num-input" };
var _hoisted_2$3 = ["title"];
var _hoisted_3$3 = { class: "__value" };
var _hoisted_4$3 = {
  key: 1,
  class: "__content"
};
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_arrow = resolveComponent("i-arrow");
  return openBlock(), createElementBlock("div", _hoisted_1$f, [
    createBaseVNode("div", {
      class: "__button --dec",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.decrement && _ctx.decrement(...args))
    }, [
      createVNode(_component_i_arrow)
    ]),
    !_ctx.editMode ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "__content",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.enterEditMode && _ctx.enterEditMode(...args))
    }, [
      createBaseVNode("div", {
        class: "__label",
        title: _ctx.intf.name
      }, toDisplayString(_ctx.intf.name), 9, _hoisted_2$3),
      createBaseVNode("div", _hoisted_3$3, toDisplayString(_ctx.stringRepresentation), 1)
    ])) : (openBlock(), createElementBlock("div", _hoisted_4$3, [
      withDirectives(createBaseVNode("input", {
        ref: "inputEl",
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.tempValue = $event),
        type: "number",
        class: normalizeClass(["baklava-input", { "--invalid": _ctx.invalid }]),
        style: { "text-align": "right" },
        onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.leaveEditMode && _ctx.leaveEditMode(...args)),
        onKeydown: _cache[4] || (_cache[4] = withKeys((...args) => _ctx.leaveEditMode && _ctx.leaveEditMode(...args), ["enter"]))
      }, null, 34), [
        [vModelText, _ctx.tempValue]
      ])
    ])),
    createBaseVNode("div", {
      class: "__button --inc",
      onClick: _cache[5] || (_cache[5] = (...args) => _ctx.increment && _ctx.increment(...args))
    }, [
      createVNode(_component_i_arrow)
    ])
  ]);
}
var IntegerInterfaceComponent = _export_sfc(_sfc_main$g, [["render", _sfc_render$f]]);
var IntegerInterface = class extends BaseNumericInterface {
  constructor() {
    super(...arguments);
    this.component = markRaw(IntegerInterfaceComponent);
  }
  validate(v) {
    return Number.isInteger(v) && super.validate(v);
  }
};
var _hoisted_1$e = { class: "baklava-num-input" };
var _hoisted_2$2 = ["title"];
var _hoisted_3$2 = { class: "__value" };
var _hoisted_4$2 = {
  key: 1,
  class: "__content"
};
var _sfc_main$f = defineComponent({
  __name: "NumberInterface",
  props: {
    intf: {}
  },
  setup(__props) {
    const props = __props;
    const { editMode, invalid, tempValue, inputEl, stringRepresentation, enterEditMode, leaveEditMode, setValue } = useBaseNumericInterface(toRef(props, "intf"));
    function increment() {
      const rounded = parseFloat((props.intf.value + 0.1).toFixed(3));
      setValue(rounded);
    }
    function decrement() {
      const rounded = parseFloat((props.intf.value - 0.1).toFixed(3));
      setValue(rounded);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$e, [
        createBaseVNode("div", {
          class: "__button --dec",
          onClick: decrement
        }, [
          createVNode(Arrow)
        ]),
        !unref(editMode) ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "__content",
          onClick: _cache[0] || (_cache[0] = //@ts-ignore
          (...args) => unref(enterEditMode) && unref(enterEditMode)(...args))
        }, [
          createBaseVNode("div", {
            class: "__label",
            title: _ctx.intf.name
          }, toDisplayString(_ctx.intf.name), 9, _hoisted_2$2),
          createBaseVNode("div", _hoisted_3$2, toDisplayString(unref(stringRepresentation)), 1)
        ])) : (openBlock(), createElementBlock("div", _hoisted_4$2, [
          withDirectives(createBaseVNode("input", {
            ref_key: "inputEl",
            ref: inputEl,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(tempValue) ? tempValue.value = $event : null),
            type: "number",
            class: normalizeClass(["baklava-input", { "--invalid": unref(invalid) }]),
            style: { "text-align": "right" },
            onBlur: _cache[2] || (_cache[2] = //@ts-ignore
            (...args) => unref(leaveEditMode) && unref(leaveEditMode)(...args)),
            onKeydown: _cache[3] || (_cache[3] = withKeys(
              //@ts-ignore
              (...args) => unref(leaveEditMode) && unref(leaveEditMode)(...args),
              ["enter"]
            ))
          }, null, 34), [
            [vModelText, unref(tempValue)]
          ])
        ])),
        createBaseVNode("div", {
          class: "__button --inc",
          onClick: increment
        }, [
          createVNode(Arrow)
        ])
      ]);
    };
  }
});
var NumberInterface = class extends BaseNumericInterface {
  constructor() {
    super(...arguments);
    this.component = markRaw(_sfc_main$f);
  }
};
var _sfc_main$e = defineComponent({
  components: {
    "i-arrow": Arrow
  },
  props: {
    intf: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const el = ref(null);
    const open = ref(false);
    const selectedItem = computed(
      () => props.intf.items.find(
        (v) => typeof v === "string" ? v === props.intf.value : v.value === props.intf.value
      )
    );
    const selectedText = computed(() => {
      if (selectedItem.value) {
        return typeof selectedItem.value === "string" ? selectedItem.value : selectedItem.value.text;
      } else {
        return "";
      }
    });
    const setSelected = (item) => {
      props.intf.value = typeof item === "string" ? item : item.value;
    };
    onClickOutside(el, () => {
      open.value = false;
    });
    return { el, open, selectedItem, selectedText, setSelected };
  }
});
var _hoisted_1$d = ["title"];
var _hoisted_2$1 = { class: "__selected" };
var _hoisted_3$1 = { class: "__text" };
var _hoisted_4$1 = { class: "__icon" };
var _hoisted_5 = { class: "__dropdown" };
var _hoisted_6 = { class: "item --header" };
var _hoisted_7 = ["onClick"];
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_i_arrow = resolveComponent("i-arrow");
  return openBlock(), createElementBlock("div", {
    ref: "el",
    class: normalizeClass(["baklava-select", { "--open": _ctx.open }]),
    title: _ctx.intf.name,
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.open = !_ctx.open)
  }, [
    createBaseVNode("div", _hoisted_2$1, [
      createBaseVNode("div", _hoisted_3$1, toDisplayString(_ctx.selectedText), 1),
      createBaseVNode("div", _hoisted_4$1, [
        createVNode(_component_i_arrow)
      ])
    ]),
    createVNode(Transition, { name: "slide-fade" }, {
      default: withCtx(() => [
        withDirectives(createBaseVNode("div", _hoisted_5, [
          createBaseVNode("div", _hoisted_6, toDisplayString(_ctx.intf.name), 1),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.intf.items, (item, i) => {
            return openBlock(), createElementBlock("div", {
              key: i,
              class: normalizeClass(["item", { "--active": item === _ctx.selectedItem }]),
              onClick: ($event) => _ctx.setSelected(item)
            }, toDisplayString(typeof item === "string" ? item : item.text), 11, _hoisted_7);
          }), 128))
        ], 512), [
          [vShow, _ctx.open]
        ])
      ]),
      _: 1
    })
  ], 10, _hoisted_1$d);
}
var SelectInterfaceComponent = _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
var SelectInterface = class extends NodeInterface {
  constructor(name, value, items) {
    super(name, value);
    this.component = markRaw(SelectInterfaceComponent);
    this.items = items;
  }
};
var _sfc_main$d = defineComponent({
  props: {
    intf: {
      type: Object,
      required: true
    }
  },
  setup(props) {
    const el = ref(null);
    const baseNumericInterface = useBaseNumericInterface(toRef(props, "intf"));
    const didSlide = ref(false);
    const isMouseDown = ref(false);
    const percentage = computed(
      () => Math.min(100, Math.max(0, (props.intf.value - props.intf.min) * 100 / (props.intf.max - props.intf.min)))
    );
    const mousedown = () => {
      if (baseNumericInterface.editMode.value) {
        return;
      }
      isMouseDown.value = true;
    };
    const mouseup = () => {
      if (baseNumericInterface.editMode.value) {
        return;
      }
      if (!didSlide.value) {
        void baseNumericInterface.enterEditMode();
      }
      isMouseDown.value = false;
      didSlide.value = false;
    };
    const mouseleave = (ev) => {
      if (baseNumericInterface.editMode.value) {
        return;
      }
      if (isMouseDown.value) {
        if (ev.offsetX >= el.value.clientWidth) {
          baseNumericInterface.setValue(props.intf.max);
        } else if (ev.offsetX <= 0) {
          baseNumericInterface.setValue(props.intf.min);
        }
      }
      isMouseDown.value = false;
      didSlide.value = false;
    };
    const mousemove = (ev) => {
      if (baseNumericInterface.editMode.value) {
        return;
      }
      const v = Math.max(
        props.intf.min,
        Math.min(
          props.intf.max,
          (props.intf.max - props.intf.min) * (ev.offsetX / el.value.clientWidth) + props.intf.min
        )
      );
      if (isMouseDown.value) {
        baseNumericInterface.setValue(v);
        didSlide.value = true;
      }
    };
    return { ...baseNumericInterface, el, percentage, mousedown, mouseup, mousemove, mouseleave };
  }
});
var _hoisted_1$c = {
  key: 0,
  class: "__content"
};
var _hoisted_2 = { class: "__label" };
var _hoisted_3 = { class: "__value" };
var _hoisted_4 = {
  key: 1,
  class: "__content"
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "el",
    class: normalizeClass(["baklava-slider", { "baklava-ignore-mouse": !_ctx.editMode }]),
    onPointerdown: _cache[3] || (_cache[3] = (...args) => _ctx.mousedown && _ctx.mousedown(...args)),
    onPointerup: _cache[4] || (_cache[4] = (...args) => _ctx.mouseup && _ctx.mouseup(...args)),
    onPointermove: _cache[5] || (_cache[5] = (...args) => _ctx.mousemove && _ctx.mousemove(...args)),
    onPointerleave: _cache[6] || (_cache[6] = (...args) => _ctx.mouseleave && _ctx.mouseleave(...args))
  }, [
    createBaseVNode("div", {
      class: "__slider",
      style: normalizeStyle({ width: _ctx.percentage + "%" })
    }, null, 4),
    !_ctx.editMode ? (openBlock(), createElementBlock("div", _hoisted_1$c, [
      createBaseVNode("div", _hoisted_2, toDisplayString(_ctx.intf.name), 1),
      createBaseVNode("div", _hoisted_3, toDisplayString(_ctx.stringRepresentation), 1)
    ])) : (openBlock(), createElementBlock("div", _hoisted_4, [
      withDirectives(createBaseVNode("input", {
        ref: "inputEl",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.tempValue = $event),
        type: "number",
        class: normalizeClass(["baklava-input", { "--invalid": _ctx.invalid }]),
        style: { "text-align": "right" },
        onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.leaveEditMode && _ctx.leaveEditMode(...args)),
        onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => _ctx.leaveEditMode && _ctx.leaveEditMode(...args), ["enter"]))
      }, null, 34), [
        [vModelText, _ctx.tempValue]
      ])
    ]))
  ], 34);
}
var SliderInterfaceComponent = _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
var SliderInterface = class extends BaseNumericInterface {
  constructor(name, value, min, max) {
    super(name, value, min, max);
    this.component = markRaw(SliderInterfaceComponent);
    this.min = min;
    this.max = max;
  }
};
var _sfc_main$c = defineComponent({
  props: {
    intf: {
      type: Object,
      required: true
    }
  }
});
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, toDisplayString(_ctx.intf.value), 1);
}
var TextInterfaceComponent = _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
var TextInterface = class extends NodeInterface {
  constructor(name, value) {
    super(name, value);
    this.component = markRaw(TextInterfaceComponent);
    this.setPort(false);
  }
};
var _sfc_main$b = defineComponent({
  props: {
    intf: {
      type: Object,
      required: true
    },
    modelValue: {
      type: String,
      required: true
    }
  },
  emits: ["update:modelValue"],
  setup(props, { emit }) {
    const v = computed({
      get: () => props.modelValue,
      set: (v2) => {
        emit("update:modelValue", v2);
      }
    });
    return { v };
  }
});
var _hoisted_1$b = ["placeholder", "title"];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    withDirectives(createBaseVNode("input", {
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.v = $event),
      type: "text",
      class: "baklava-input",
      placeholder: _ctx.intf.name,
      title: _ctx.intf.name
    }, null, 8, _hoisted_1$b), [
      [vModelText, _ctx.v]
    ])
  ]);
}
var TextInputInterfaceComponent = _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
var TextInputInterface = class extends NodeInterface {
  constructor() {
    super(...arguments);
    this.component = markRaw(TextInputInterfaceComponent);
  }
};
var _sfc_main$a = defineComponent({
  props: {
    intf: {
      type: Object,
      required: true
    },
    modelValue: {
      type: String,
      required: true
    }
  },
  emits: ["update:modelValue"],
  setup(props, { emit }) {
    const v = computed({
      get: () => props.modelValue,
      set: (v2) => {
        emit("update:modelValue", v2);
      }
    });
    return { v };
  }
});
var _hoisted_1$a = ["placeholder", "title"];
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    withDirectives(createBaseVNode("textarea", {
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.v = $event),
      rows: "5",
      class: "baklava-input",
      placeholder: _ctx.intf.name,
      title: _ctx.intf.name
    }, null, 8, _hoisted_1$a), [
      [vModelText, _ctx.v]
    ])
  ]);
}
var TextareaInputInterfaceComponent = _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
var TextareaInputInterface = class extends NodeInterface {
  constructor() {
    super(...arguments);
    this.component = markRaw(TextareaInputInterfaceComponent);
  }
};
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = { randomUUID };
function v4(options, buf, offset) {
  var _a;
  if (native.randomUUID && true && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
var SAVE_SUBGRAPH_COMMAND = "SAVE_SUBGRAPH";
function registerSaveSubgraphCommand(displayedGraph, handler) {
  const saveSubgraph = () => {
    const graph = displayedGraph.value;
    if (!graph.template) {
      throw new Error("Graph template property not set");
    }
    graph.template.update(graph.save());
    graph.template.panning = graph.panning;
    graph.template.scaling = graph.scaling;
  };
  handler.registerCommand(SAVE_SUBGRAPH_COMMAND, {
    canExecute: () => {
      var _a;
      return displayedGraph.value !== ((_a = displayedGraph.value.editor) == null ? void 0 : _a.graph);
    },
    execute: saveSubgraph
  });
}
var SubgraphInputNode = class extends GraphInputNode {
  constructor() {
    super(...arguments);
    this._title = "Subgraph Input";
    this.inputs = {
      name: new TextInputInterface("Name", "Input").setPort(false)
    };
    this.outputs = {
      placeholder: new NodeInterface("Connection", void 0)
    };
  }
};
var SubgraphOutputNode = class extends GraphOutputNode {
  constructor() {
    super(...arguments);
    this._title = "Subgraph Output";
    this.inputs = {
      name: new TextInputInterface("Name", "Output").setPort(false),
      placeholder: new NodeInterface("Connection", void 0)
    };
    this.outputs = {
      output: new NodeInterface("Output", void 0).setHidden(true)
    };
  }
};
var CREATE_SUBGRAPH_COMMAND = "CREATE_SUBGRAPH";
var IGNORE_NODE_TYPES = [GRAPH_INPUT_NODE_TYPE, GRAPH_OUTPUT_NODE_TYPE];
function registerCreateSubgraphCommand(displayedGraph, handler, switchGraph) {
  const canCreateSubgraph = () => {
    return displayedGraph.value.selectedNodes.filter((n) => !IGNORE_NODE_TYPES.includes(n.type)).length > 0;
  };
  const createSubgraph = () => {
    const { viewModel } = useViewModel();
    const graph = displayedGraph.value;
    const editor = displayedGraph.value.editor;
    if (graph.selectedNodes.length === 0) {
      return;
    }
    const selectedNodes = graph.selectedNodes.filter((n) => !IGNORE_NODE_TYPES.includes(n.type));
    const selectedNodesInputs = selectedNodes.flatMap((n) => Object.values(n.inputs));
    const selectedNodesOutputs = selectedNodes.flatMap((n) => Object.values(n.outputs));
    const inputConnections = graph.connections.filter(
      (c) => !selectedNodesOutputs.includes(c.from) && selectedNodesInputs.includes(c.to)
    );
    const outputConnections = graph.connections.filter(
      (c) => selectedNodesOutputs.includes(c.from) && !selectedNodesInputs.includes(c.to)
    );
    const innerConnections = graph.connections.filter(
      (c) => selectedNodesOutputs.includes(c.from) && selectedNodesInputs.includes(c.to)
    );
    const nodeStates = selectedNodes.map((n) => n.save());
    const connectionStates = innerConnections.map((c) => ({
      id: c.id,
      from: c.from.id,
      to: c.to.id
    }));
    const interfaceIdMap = /* @__PURE__ */ new Map();
    const { xLeft, xRight, yTop } = getBoundingBoxForNodes(selectedNodes);
    for (const [idx, conn] of inputConnections.entries()) {
      const inputNode = new SubgraphInputNode();
      inputNode.inputs.name.value = conn.to.name;
      nodeStates.push({
        ...inputNode.save(),
        position: { x: xRight - viewModel.value.settings.nodes.defaultWidth - 100, y: yTop + idx * 200 }
      });
      connectionStates.push({ id: v4(), from: inputNode.outputs.placeholder.id, to: conn.to.id });
      interfaceIdMap.set(conn.to.id, inputNode.graphInterfaceId);
    }
    for (const [idx, conn] of outputConnections.entries()) {
      const outputNode = new SubgraphOutputNode();
      outputNode.inputs.name.value = conn.from.name;
      nodeStates.push({
        ...outputNode.save(),
        position: { x: xLeft + 100, y: yTop + idx * 200 }
      });
      connectionStates.push({ id: v4(), from: conn.from.id, to: outputNode.inputs.placeholder.id });
      interfaceIdMap.set(conn.from.id, outputNode.graphInterfaceId);
    }
    const subgraphTemplate = reactive(
      new GraphTemplate(
        {
          connections: connectionStates,
          nodes: nodeStates,
          // ignored, but still providing to make TS happy
          inputs: [],
          outputs: []
        },
        editor
      )
    );
    editor.addGraphTemplate(subgraphTemplate);
    const nt = editor.nodeTypes.get(getGraphNodeTypeString(subgraphTemplate));
    if (!nt) {
      throw new Error("Unable to create subgraph: Could not find corresponding graph node type");
    }
    graph.activeTransactions++;
    const node = reactive(new nt.type());
    graph.addNode(node);
    const averageX = Math.round(
      selectedNodes.map((n) => n.position.x).reduce((p, c) => p + c, 0) / selectedNodes.length
    );
    const averageY = Math.round(
      selectedNodes.map((n) => n.position.y).reduce((p, c) => p + c, 0) / selectedNodes.length
    );
    node.position.x = averageX;
    node.position.y = averageY;
    inputConnections.forEach((c) => {
      graph.removeConnection(c);
      graph.addConnection(c.from, node.inputs[interfaceIdMap.get(c.to.id)]);
    });
    outputConnections.forEach((c) => {
      graph.removeConnection(c);
      graph.addConnection(node.outputs[interfaceIdMap.get(c.from.id)], c.to);
    });
    selectedNodes.forEach((n) => graph.removeNode(n));
    graph.activeTransactions--;
    if (handler.canExecuteCommand(SAVE_SUBGRAPH_COMMAND)) {
      handler.executeCommand(SAVE_SUBGRAPH_COMMAND);
    }
    switchGraph(subgraphTemplate);
    displayedGraph.value.panning = { ...graph.panning };
    displayedGraph.value.scaling = graph.scaling;
  };
  handler.registerCommand(CREATE_SUBGRAPH_COMMAND, {
    canExecute: canCreateSubgraph,
    execute: createSubgraph
  });
}
function getBoundingBoxForNodes(nodes) {
  const xRight = nodes.reduce((acc, cur) => {
    const x = cur.position.x;
    return x < acc ? x : acc;
  }, Infinity);
  const yTop = nodes.reduce((acc, cur) => {
    const y = cur.position.y;
    return y < acc ? y : acc;
  }, Infinity);
  const xLeft = nodes.reduce((acc, cur) => {
    const x = cur.position.x + cur.width;
    return x > acc ? x : acc;
  }, -Infinity);
  return { xLeft, xRight, yTop };
}
var NodeStep = class {
  constructor(type, data) {
    this.type = type;
    if (type === "addNode") {
      this.nodeId = data;
    } else {
      this.nodeState = data;
    }
  }
  undo(graph) {
    if (this.type === "addNode") {
      this.removeNode(graph);
    } else {
      this.addNode(graph);
    }
  }
  redo(graph) {
    if (this.type === "addNode" && this.nodeState) {
      this.addNode(graph);
    } else if (this.type === "removeNode" && this.nodeId) {
      this.removeNode(graph);
    }
  }
  addNode(graph) {
    const nodeType = graph.editor.nodeTypes.get(this.nodeState.type);
    if (!nodeType) {
      return;
    }
    const n = new nodeType.type();
    graph.addNode(n);
    n.load(this.nodeState);
    this.nodeId = n.id;
  }
  removeNode(graph) {
    const node = graph.nodes.find((n) => n.id === this.nodeId);
    if (!node) {
      return;
    }
    this.nodeState = node.save();
    graph.removeNode(node);
  }
};
var ConnectionStep = class {
  constructor(type, data) {
    this.type = type;
    if (type === "addConnection") {
      this.connectionId = data;
    } else {
      const d = data;
      this.connectionState = {
        id: d.id,
        from: d.from.id,
        to: d.to.id
      };
    }
  }
  undo(graph) {
    if (this.type === "addConnection") {
      this.removeConnection(graph);
    } else {
      this.addConnection(graph);
    }
  }
  redo(graph) {
    if (this.type === "addConnection" && this.connectionState) {
      this.addConnection(graph);
    } else if (this.type === "removeConnection" && this.connectionId) {
      this.removeConnection(graph);
    }
  }
  addConnection(graph) {
    const fromIntf = graph.findNodeInterface(this.connectionState.from);
    const toIntf = graph.findNodeInterface(this.connectionState.to);
    if (!fromIntf || !toIntf) {
      return;
    }
    const connection = graph.addConnection(fromIntf, toIntf);
    if (connection) {
      connection.id = this.connectionState.id;
    }
    this.connectionId = connection == null ? void 0 : connection.id;
  }
  removeConnection(graph) {
    const connection = graph.connections.find((c) => c.id === this.connectionId);
    if (!connection) {
      return;
    }
    this.connectionState = {
      id: connection.id,
      from: connection.from.id,
      to: connection.to.id
    };
    graph.removeConnection(connection);
  }
};
var TransactionStep = class {
  constructor(steps) {
    this.type = "transaction";
    if (steps.length === 0) {
      throw new Error("Can't create a transaction with no steps");
    }
    this.steps = steps;
  }
  undo(graph) {
    for (let i = this.steps.length - 1; i >= 0; i--) {
      this.steps[i].undo(graph);
    }
  }
  redo(graph) {
    for (let i = 0; i < this.steps.length; i++) {
      this.steps[i].redo(graph);
    }
  }
};
var UNDO_COMMAND = "UNDO";
var REDO_COMMAND = "REDO";
var START_TRANSACTION_COMMAND = "START_TRANSACTION";
var COMMIT_TRANSACTION_COMMAND = "COMMIT_TRANSACTION";
var CLEAR_HISTORY_COMMAND = "CLEAR_HISTORY";
function useHistory(graph, commandHandler) {
  const token = Symbol("HistoryToken");
  const maxSteps = ref(200);
  const steps = ref([]);
  const changeBySelf = ref(false);
  const currentIndex = ref(-1);
  const activeTransaction = ref(false);
  const transactionSteps = ref([]);
  const addStep = (step) => {
    if (changeBySelf.value) {
      return;
    }
    if (activeTransaction.value) {
      transactionSteps.value.push(step);
    } else {
      if (currentIndex.value !== steps.value.length - 1) {
        steps.value = steps.value.slice(0, currentIndex.value + 1);
      }
      steps.value.push(step);
      while (steps.value.length > maxSteps.value) {
        steps.value.shift();
      }
      currentIndex.value = steps.value.length - 1;
    }
  };
  const startTransaction = () => {
    activeTransaction.value = true;
  };
  const commitTransaction = () => {
    activeTransaction.value = false;
    if (transactionSteps.value.length > 0) {
      addStep(new TransactionStep(transactionSteps.value));
      transactionSteps.value = [];
    }
  };
  const canUndo = () => steps.value.length !== 0 && currentIndex.value !== -1;
  const undo = () => {
    if (!canUndo()) {
      return;
    }
    changeBySelf.value = true;
    steps.value[currentIndex.value--].undo(graph.value);
    changeBySelf.value = false;
  };
  const canRedo = () => steps.value.length !== 0 && currentIndex.value < steps.value.length - 1;
  const redo = () => {
    if (!canRedo()) {
      return;
    }
    changeBySelf.value = true;
    steps.value[++currentIndex.value].redo(graph.value);
    changeBySelf.value = false;
  };
  const clear = () => {
    steps.value = [];
    currentIndex.value = -1;
  };
  watch(
    graph,
    (newGraph, oldGraph) => {
      if (oldGraph) {
        oldGraph.events.addNode.unsubscribe(token);
        oldGraph.events.removeNode.unsubscribe(token);
        oldGraph.events.addConnection.unsubscribe(token);
        oldGraph.events.removeConnection.unsubscribe(token);
      }
      if (newGraph) {
        newGraph.events.addNode.subscribe(token, (node) => {
          addStep(new NodeStep("addNode", node.id));
        });
        newGraph.events.removeNode.subscribe(token, (node) => {
          addStep(new NodeStep("removeNode", node.save()));
        });
        newGraph.events.addConnection.subscribe(token, (conn) => {
          addStep(new ConnectionStep("addConnection", conn.id));
        });
        newGraph.events.removeConnection.subscribe(token, (conn) => {
          addStep(new ConnectionStep("removeConnection", conn));
        });
      }
    },
    { immediate: true }
  );
  commandHandler.registerCommand(UNDO_COMMAND, {
    canExecute: canUndo,
    execute: undo
  });
  commandHandler.registerCommand(REDO_COMMAND, {
    canExecute: canRedo,
    execute: redo
  });
  commandHandler.registerCommand(START_TRANSACTION_COMMAND, {
    canExecute: () => !activeTransaction.value,
    execute: startTransaction
  });
  commandHandler.registerCommand(COMMIT_TRANSACTION_COMMAND, {
    canExecute: () => activeTransaction.value,
    execute: commitTransaction
  });
  commandHandler.registerCommand(CLEAR_HISTORY_COMMAND, {
    canExecute: () => steps.value.length > 0,
    execute: clear
  });
  commandHandler.registerHotkey(["Control", "z"], UNDO_COMMAND);
  commandHandler.registerHotkey(["Control", "y"], REDO_COMMAND);
  return reactive({
    maxSteps
  });
}
var DELETE_NODES_COMMAND = "DELETE_NODES";
function registerDeleteNodesCommand(displayedGraph, handler) {
  handler.registerCommand(DELETE_NODES_COMMAND, {
    canExecute: () => displayedGraph.value.selectedNodes.length > 0,
    execute() {
      handler.executeCommand(START_TRANSACTION_COMMAND);
      for (let i = displayedGraph.value.selectedNodes.length - 1; i >= 0; i--) {
        const n = displayedGraph.value.selectedNodes[i];
        displayedGraph.value.removeNode(n);
      }
      handler.executeCommand(COMMIT_TRANSACTION_COMMAND);
    }
  });
  handler.registerHotkey(["Delete"], DELETE_NODES_COMMAND);
}
var SWITCH_TO_MAIN_GRAPH_COMMAND = "SWITCH_TO_MAIN_GRAPH";
function registerSwitchToMainGraphCommand(displayedGraph, handler, switchGraph) {
  handler.registerCommand(SWITCH_TO_MAIN_GRAPH_COMMAND, {
    canExecute: () => displayedGraph.value !== displayedGraph.value.editor.graph,
    execute: () => {
      handler.executeCommand(SAVE_SUBGRAPH_COMMAND);
      switchGraph(displayedGraph.value.editor.graph);
    }
  });
}
function registerGraphCommands(displayedGraph, handler, switchGraph) {
  registerDeleteNodesCommand(displayedGraph, handler);
  registerCreateSubgraphCommand(displayedGraph, handler, switchGraph);
  registerSaveSubgraphCommand(displayedGraph, handler);
  registerSwitchToMainGraphCommand(displayedGraph, handler, switchGraph);
}
var COPY_COMMAND = "COPY";
var PASTE_COMMAND = "PASTE";
var CLEAR_CLIPBOARD_COMMAND = "CLEAR_CLIPBOARD";
function useClipboard(displayedGraph, editor, commandHandler) {
  const token = Symbol("ClipboardToken");
  const nodeBuffer = ref("");
  const connectionBuffer = ref("");
  const isEmpty = computed(() => !nodeBuffer.value);
  const clear = () => {
    nodeBuffer.value = "";
    connectionBuffer.value = "";
  };
  const copy = () => {
    const interfacesOfSelectedNodes = displayedGraph.value.selectedNodes.flatMap((n) => [
      ...Object.values(n.inputs),
      ...Object.values(n.outputs)
    ]);
    const connections = displayedGraph.value.connections.filter(
      (conn) => interfacesOfSelectedNodes.includes(conn.from) || interfacesOfSelectedNodes.includes(conn.to)
    ).map((conn) => ({ from: conn.from.id, to: conn.to.id }));
    connectionBuffer.value = JSON.stringify(connections);
    nodeBuffer.value = JSON.stringify(displayedGraph.value.selectedNodes.map((n) => n.save()));
  };
  const findInterface = (nodes, id, io) => {
    for (const n of nodes) {
      let intf;
      if (!io || io === "input") {
        intf = Object.values(n.inputs).find((intf2) => intf2.id === id);
      }
      if (!intf && (!io || io === "output")) {
        intf = Object.values(n.outputs).find((intf2) => intf2.id === id);
      }
      if (intf) {
        return intf;
      }
    }
    return void 0;
  };
  const paste = () => {
    if (isEmpty.value) {
      return;
    }
    const idmap = /* @__PURE__ */ new Map();
    const parsedNodeBuffer = JSON.parse(nodeBuffer.value);
    const parsedConnectionBuffer = JSON.parse(connectionBuffer.value);
    const newNodes = [];
    const newConnections = [];
    const graph = displayedGraph.value;
    commandHandler.executeCommand(START_TRANSACTION_COMMAND);
    for (const oldNode of parsedNodeBuffer) {
      const nodeType = editor.value.nodeTypes.get(oldNode.type);
      if (!nodeType) {
        console.warn(`Node type ${oldNode.type} not registered`);
        return;
      }
      const copiedNode = new nodeType.type();
      const generatedId = copiedNode.id;
      newNodes.push(copiedNode);
      copiedNode.hooks.beforeLoad.subscribe(token, (nodeState) => {
        const ns = nodeState;
        if (ns.position) {
          ns.position.x += 100;
          ns.position.y += 100;
        }
        copiedNode.hooks.beforeLoad.unsubscribe(token);
        return ns;
      });
      graph.addNode(copiedNode);
      copiedNode.load({ ...oldNode, id: generatedId });
      copiedNode.id = generatedId;
      idmap.set(oldNode.id, generatedId);
      for (const intf of Object.values(copiedNode.inputs)) {
        const newIntfId = v4();
        idmap.set(intf.id, newIntfId);
        intf.id = newIntfId;
      }
      for (const intf of Object.values(copiedNode.outputs)) {
        const newIntfId = v4();
        idmap.set(intf.id, newIntfId);
        intf.id = newIntfId;
      }
    }
    for (const c of parsedConnectionBuffer) {
      const fromIntf = findInterface(newNodes, idmap.get(c.from), "output");
      const toIntf = findInterface(newNodes, idmap.get(c.to), "input");
      if (!fromIntf || !toIntf) {
        continue;
      }
      const newConnection = graph.addConnection(fromIntf, toIntf);
      if (newConnection) {
        newConnections.push(newConnection);
      }
    }
    displayedGraph.value.selectedNodes = newNodes;
    commandHandler.executeCommand(COMMIT_TRANSACTION_COMMAND);
    return {
      newNodes,
      newConnections
    };
  };
  commandHandler.registerCommand(COPY_COMMAND, {
    canExecute: () => displayedGraph.value.selectedNodes.length > 0,
    execute: copy
  });
  commandHandler.registerHotkey(["Control", "c"], COPY_COMMAND);
  commandHandler.registerCommand(PASTE_COMMAND, {
    canExecute: () => !isEmpty.value,
    execute: paste
  });
  commandHandler.registerHotkey(["Control", "v"], PASTE_COMMAND);
  commandHandler.registerCommand(CLEAR_CLIPBOARD_COMMAND, {
    canExecute: () => true,
    execute: clear
  });
  return reactive({ isEmpty });
}
var OPEN_SIDEBAR_COMMAND = "OPEN_SIDEBAR";
function registerOpenSidebarCommand(displayedGraph, handler) {
  handler.registerCommand(OPEN_SIDEBAR_COMMAND, {
    execute: (nodeId) => {
      displayedGraph.value.sidebar.nodeId = nodeId;
      displayedGraph.value.sidebar.visible = true;
    },
    canExecute: () => true
  });
}
var displayInSidebar = (intf, displayInSidebar2) => {
  intf.displayInSidebar = displayInSidebar2;
};
function registerSidebarCommands(displayedGraph, handler) {
  registerOpenSidebarCommand(displayedGraph, handler);
}
var ZOOM_TO_FIT_RECT_COMMAND = "ZOOM_TO_FIT_RECT";
var ZOOM_TO_FIT_NODES_COMMAND = "ZOOM_TO_FIT_NODES";
var ZOOM_TO_FIT_GRAPH_COMMAND = "ZOOM_TO_FIT_GRAPH";
function registerZoomToFitCommands(displayedGraph, handler, settings) {
  handler.registerCommand(ZOOM_TO_FIT_RECT_COMMAND, {
    canExecute: () => true,
    execute: (rect) => zoomToFitRect(displayedGraph.value, settings, rect)
  });
  handler.registerCommand(ZOOM_TO_FIT_NODES_COMMAND, {
    canExecute: () => true,
    execute: (nodes) => zoomToFitNodes(displayedGraph.value, settings, nodes)
  });
  handler.registerCommand(ZOOM_TO_FIT_GRAPH_COMMAND, {
    canExecute: () => displayedGraph.value.nodes.length > 0,
    execute: () => zoomToFitGraph(displayedGraph.value, settings)
  });
  handler.registerHotkey(["f"], ZOOM_TO_FIT_GRAPH_COMMAND);
}
function zoomToFitRect(graph, settings, rect) {
  const padding = {
    left: settings.zoomToFit.paddingLeft,
    right: settings.zoomToFit.paddingRight,
    top: settings.zoomToFit.paddingTop,
    bottom: settings.zoomToFit.paddingBottom
  };
  const editorEl = document.querySelector(".baklava-editor");
  const editorBounding = editorEl.getBoundingClientRect();
  const editorWidth = Math.max(0, editorBounding.width - padding.left - padding.right);
  const editorHeight = Math.max(0, editorBounding.height - padding.top - padding.bottom);
  rect = normalizeRect(rect);
  const rectWidth = rect.x2 - rect.x1;
  const rectHeight = rect.y2 - rect.y1;
  const widthRatio = rectWidth === 0 ? Infinity : editorWidth / rectWidth;
  const heightRatio = rectHeight == 0 ? Infinity : editorHeight / rectHeight;
  let scale = Math.min(widthRatio, heightRatio);
  if (scale === 0 || !Number.isFinite(scale)) {
    scale = 1;
  }
  const remainingEditorWidth = Math.max(0, editorWidth / scale - rectWidth);
  const remainingEditorHeight = Math.max(0, editorHeight / scale - rectHeight);
  const offsetX = -rect.x1 + padding.left / scale + remainingEditorWidth / 2;
  const offsetY = -rect.y1 + padding.top / scale + remainingEditorHeight / 2;
  graph.panning.x = offsetX;
  graph.panning.y = offsetY;
  graph.scaling = scale;
}
function zoomToFitNodes(graph, settings, nodes) {
  if (nodes.length === 0) {
    return;
  }
  const nodeRects = nodes.map(getNodeRect);
  const boundingRect = {
    x1: Math.min(...nodeRects.map((i) => i.x1)),
    y1: Math.min(...nodeRects.map((i) => i.y1)),
    x2: Math.max(...nodeRects.map((i) => i.x2)),
    y2: Math.max(...nodeRects.map((i) => i.y2))
  };
  zoomToFitRect(graph, settings, boundingRect);
}
function zoomToFitGraph(graph, settings) {
  zoomToFitNodes(graph, settings, graph.nodes);
}
function getNodeRect(node) {
  var _a, _b;
  const domElement = document.getElementById(node.id);
  const width = (domElement == null ? void 0 : domElement.offsetWidth) ?? 0;
  const height = (domElement == null ? void 0 : domElement.offsetHeight) ?? 0;
  const posX = ((_a = node.position) == null ? void 0 : _a.x) ?? 0;
  const posY = ((_b = node.position) == null ? void 0 : _b.y) ?? 0;
  return {
    x1: posX,
    y1: posY,
    x2: posX + width,
    y2: posY + height
  };
}
function normalizeRect(rect) {
  return {
    x1: Math.min(rect.x1, rect.x2),
    y1: Math.min(rect.y1, rect.y2),
    x2: Math.max(rect.x1, rect.x2),
    y2: Math.max(rect.y1, rect.y2)
  };
}
var commandList = Object.freeze(Object.defineProperty({
  __proto__: null,
  CLEAR_CLIPBOARD_COMMAND,
  CLEAR_HISTORY_COMMAND,
  COMMIT_TRANSACTION_COMMAND,
  COPY_COMMAND,
  CREATE_SUBGRAPH_COMMAND,
  DELETE_NODES_COMMAND,
  OPEN_SIDEBAR_COMMAND,
  PASTE_COMMAND,
  REDO_COMMAND,
  SAVE_SUBGRAPH_COMMAND,
  START_SELECTION_BOX_COMMAND,
  START_TRANSACTION_COMMAND,
  SWITCH_TO_MAIN_GRAPH_COMMAND,
  UNDO_COMMAND,
  ZOOM_TO_FIT_GRAPH_COMMAND,
  ZOOM_TO_FIT_NODES_COMMAND,
  ZOOM_TO_FIT_RECT_COMMAND
}, Symbol.toStringTag, { value: "Module" }));
var _sfc_main$9 = {};
var _hoisted_1$9 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "baklava-icon",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  "stroke-width": "2",
  stroke: "currentColor",
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _sfc_render$9(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$9, _cache[0] || (_cache[0] = [
    createBaseVNode("path", {
      stroke: "none",
      d: "M0 0h24v24H0z",
      fill: "none"
    }, null, -1),
    createBaseVNode("path", { d: "M9 13l-4 -4l4 -4m-4 4h11a4 4 0 0 1 0 8h-1" }, null, -1)
  ]));
}
var ArrowBackUp = _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
var _sfc_main$8 = {};
var _hoisted_1$8 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "baklava-icon",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  "stroke-width": "2",
  stroke: "currentColor",
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _sfc_render$8(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$8, _cache[0] || (_cache[0] = [
    createBaseVNode("path", {
      stroke: "none",
      d: "M0 0h24v24H0z",
      fill: "none"
    }, null, -1),
    createBaseVNode("path", { d: "M15 13l4 -4l-4 -4m4 4h-11a4 4 0 0 0 0 8h1" }, null, -1)
  ]));
}
var ArrowForwardUp = _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
var _sfc_main$7 = {};
var _hoisted_1$7 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "baklava-icon",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  "stroke-width": "2",
  stroke: "currentColor",
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _sfc_render$7(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$7, _cache[0] || (_cache[0] = [
    createBaseVNode("path", {
      stroke: "none",
      d: "M0 0h24v24H0z",
      fill: "none"
    }, null, -1),
    createBaseVNode("line", {
      x1: "5",
      y1: "12",
      x2: "19",
      y2: "12"
    }, null, -1),
    createBaseVNode("line", {
      x1: "5",
      y1: "12",
      x2: "11",
      y2: "18"
    }, null, -1),
    createBaseVNode("line", {
      x1: "5",
      y1: "12",
      x2: "11",
      y2: "6"
    }, null, -1)
  ]));
}
var ArrowLeft = _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
var _sfc_main$6 = {};
var _hoisted_1$6 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "baklava-icon",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  "stroke-width": "2",
  stroke: "currentColor",
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _sfc_render$6(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$6, _cache[0] || (_cache[0] = [
    createBaseVNode("path", {
      stroke: "none",
      d: "M0 0h24v24H0z",
      fill: "none"
    }, null, -1),
    createBaseVNode("path", { d: "M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" }, null, -1),
    createBaseVNode("rect", {
      x: "9",
      y: "3",
      width: "6",
      height: "4",
      rx: "2"
    }, null, -1)
  ]));
}
var Clipboard = _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
var _sfc_main$5 = {};
var _hoisted_1$5 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "baklava-icon",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  "stroke-width": "2",
  stroke: "currentColor",
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _sfc_render$5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5, _cache[0] || (_cache[0] = [
    createBaseVNode("path", {
      stroke: "none",
      d: "M0 0h24v24H0z",
      fill: "none"
    }, null, -1),
    createBaseVNode("rect", {
      x: "8",
      y: "8",
      width: "12",
      height: "12",
      rx: "2"
    }, null, -1),
    createBaseVNode("path", { d: "M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2" }, null, -1)
  ]));
}
var Copy = _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
var _sfc_main$4 = {};
var _hoisted_1$4 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "baklava-icon",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  "stroke-width": "2",
  stroke: "currentColor",
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _sfc_render$4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4, _cache[0] || (_cache[0] = [
    createBaseVNode("path", {
      stroke: "none",
      d: "M0 0h24v24H0z",
      fill: "none"
    }, null, -1),
    createBaseVNode("path", { d: "M6 4h10l4 4v10a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2" }, null, -1),
    createBaseVNode("circle", {
      cx: "12",
      cy: "14",
      r: "2"
    }, null, -1),
    createBaseVNode("polyline", { points: "14 4 14 8 8 8 8 4" }, null, -1)
  ]));
}
var DeviceFloppy = _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
var _sfc_main$3 = {};
var _hoisted_1$3 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "baklava-icon",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  "stroke-width": "2",
  stroke: "currentColor",
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _sfc_render$3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3, _cache[0] || (_cache[0] = [
    createStaticVNode('<path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M10 3h4v4h-4z"></path><path d="M3 17h4v4h-4z"></path><path d="M17 17h4v4h-4z"></path><path d="M7 17l5 -4l5 4"></path><line x1="12" y1="7" x2="12" y2="13"></line>', 6)
  ]));
}
var Hierarchy2 = _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
var _sfc_main$2 = {};
var _hoisted_1$2 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "baklava-icon",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  "stroke-width": "1.5",
  stroke: "currentColor",
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _sfc_render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2, _cache[0] || (_cache[0] = [
    createStaticVNode('<path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 1a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-6a1 1 0 0 1 -1 -1z"></path><path d="M12 20v.01"></path><path d="M16 20v.01"></path><path d="M8 20v.01"></path><path d="M4 20v.01"></path><path d="M4 16v.01"></path><path d="M4 12v.01"></path><path d="M4 8v.01"></path><path d="M4 4v.01"></path><path d="M8 4v.01"></path><path d="M12 4v.01"></path><path d="M16 4v.01"></path><path d="M20 4v.01"></path><path d="M20 8v.01"></path><path d="M20 12v.01"></path><path d="M20 16v.01"></path><path d="M20 20v.01"></path>', 18)
  ]));
}
var SelectAll = _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
var _sfc_main$1 = {};
var _hoisted_1$1 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "baklava-icon",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  "stroke-width": "1.5",
  stroke: "currentColor",
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _sfc_render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1, _cache[0] || (_cache[0] = [
    createStaticVNode('<path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M4 7l16 0"></path><path d="M10 11l0 6"></path><path d="M14 11l0 6"></path><path d="M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12"></path><path d="M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3"></path>', 6)
  ]));
}
var Trash = _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
var _sfc_main = {};
var _hoisted_1 = {
  xmlns: "http://www.w3.org/2000/svg",
  class: "baklava-icon",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  "stroke-width": "2",
  stroke: "currentColor",
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1, _cache[0] || (_cache[0] = [
    createStaticVNode('<path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M4 8v-2a2 2 0 0 1 2 -2h2"></path><path d="M4 16v2a2 2 0 0 0 2 2h2"></path><path d="M16 4h2a2 2 0 0 1 2 2v2"></path><path d="M16 20h2a2 2 0 0 0 2 -2v-2"></path><path d="M8 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0"></path><path d="M16 16l-2.5 -2.5"></path>', 7)
  ]));
}
var ZoomScan = _export_sfc(_sfc_main, [["render", _sfc_render]]);
var TOOLBAR_COMMANDS = {
  COPY: { command: COPY_COMMAND, title: "Copy", icon: Copy },
  PASTE: { command: PASTE_COMMAND, title: "Paste", icon: Clipboard },
  DELETE_NODES: { command: DELETE_NODES_COMMAND, title: "Delete selected nodes", icon: Trash },
  UNDO: { command: UNDO_COMMAND, title: "Undo", icon: ArrowBackUp },
  REDO: { command: REDO_COMMAND, title: "Redo", icon: ArrowForwardUp },
  ZOOM_TO_FIT_GRAPH: { command: ZOOM_TO_FIT_GRAPH_COMMAND, title: "Zoom to Fit", icon: ZoomScan },
  START_SELECTION_BOX: { command: START_SELECTION_BOX_COMMAND, title: "Box Select", icon: SelectAll },
  CREATE_SUBGRAPH: { command: CREATE_SUBGRAPH_COMMAND, title: "Create Subgraph", icon: Hierarchy2 }
};
var DEFAULT_TOOLBAR_COMMANDS = Object.values(TOOLBAR_COMMANDS);
var TOOLBAR_SUBGRAPH_COMMANDS = {
  SAVE_SUBGRAPH: { command: SAVE_SUBGRAPH_COMMAND, title: "Save Subgraph", icon: DeviceFloppy },
  SWITCH_TO_MAIN_GRAPH: { command: SWITCH_TO_MAIN_GRAPH_COMMAND, title: "Back to Main Graph", icon: ArrowLeft }
};
var DEFAULT_TOOLBAR_SUBGRAPH_COMMANDS = Object.values(TOOLBAR_SUBGRAPH_COMMANDS);
var isTemplate = (g) => !(g instanceof Graph);
function useSwitchGraph(editor, displayedGraph) {
  const switchGraph = (newGraph) => {
    let newGraphInstance;
    if (!isTemplate(newGraph)) {
      if (newGraph !== editor.value.graph) {
        throw new Error(
          "Can only switch using 'Graph' instance when it is the root graph. Otherwise a 'GraphTemplate' must be used."
        );
      }
      newGraphInstance = newGraph;
    } else {
      newGraphInstance = new Graph(editor.value);
      newGraph.createGraph(newGraphInstance);
    }
    if (displayedGraph.value && displayedGraph.value !== editor.value.graph) {
      displayedGraph.value.destroy();
    }
    newGraphInstance.panning = newGraphInstance.panning ?? newGraph.panning ?? { x: 0, y: 0 };
    newGraphInstance.scaling = newGraphInstance.scaling ?? newGraph.scaling ?? 1;
    newGraphInstance.selectedNodes = newGraphInstance.selectedNodes ?? [];
    newGraphInstance.sidebar = newGraphInstance.sidebar ?? { visible: false, nodeId: "", optionName: "" };
    displayedGraph.value = newGraphInstance;
  };
  return { switchGraph };
}
function setViewNodeProperties(node, settings) {
  node.position = node.position ?? { x: 0, y: 0 };
  node.disablePointerEvents = false;
  node.twoColumn = node.twoColumn ?? false;
  node.width = node.width ?? settings.defaultWidth;
}
var DEFAULT_SETTINGS = () => ({
  useStraightConnections: false,
  enableMinimap: false,
  toolbar: { enabled: true, commands: DEFAULT_TOOLBAR_COMMANDS, subgraphCommands: DEFAULT_TOOLBAR_SUBGRAPH_COMMANDS },
  palette: { enabled: true },
  background: { gridSize: 100, gridDivision: 5, subGridVisibleThreshold: 0.6 },
  sidebar: { enabled: true, width: 300, resizable: true },
  displayValueOnHover: false,
  nodes: { defaultWidth: 200, maxWidth: 320, minWidth: 150, resizable: false, reverseY: false },
  contextMenu: { enabled: true, additionalItems: [] },
  zoomToFit: { paddingLeft: 300, paddingRight: 50, paddingTop: 110, paddingBottom: 50 }
});
function useBaklava(existingEditor) {
  const editor = ref(existingEditor ?? new Editor());
  const token = Symbol("ViewModelToken");
  const _displayedGraph = ref(null);
  const displayedGraph = shallowReadonly(_displayedGraph);
  const { switchGraph } = useSwitchGraph(editor, _displayedGraph);
  const isSubgraph = computed(() => displayedGraph.value && displayedGraph.value !== editor.value.graph);
  const settings = reactive(DEFAULT_SETTINGS());
  const commandHandler = useCommandHandler();
  const history = useHistory(displayedGraph, commandHandler);
  const clipboard = useClipboard(displayedGraph, editor, commandHandler);
  const hooks = {
    /** Called whenever a node is rendered */
    renderNode: new SequentialHook(null),
    /** Called whenever an interface is rendered */
    renderInterface: new SequentialHook(null)
  };
  registerGraphCommands(displayedGraph, commandHandler, switchGraph);
  registerSidebarCommands(displayedGraph, commandHandler);
  registerZoomToFitCommands(displayedGraph, commandHandler, settings);
  watch(
    editor,
    (newValue, oldValue) => {
      if (oldValue) {
        oldValue.events.registerGraph.unsubscribe(token);
        oldValue.graphEvents.beforeAddNode.unsubscribe(token);
        newValue.nodeHooks.beforeLoad.unsubscribe(token);
        newValue.nodeHooks.afterSave.unsubscribe(token);
        newValue.graphTemplateHooks.beforeLoad.unsubscribe(token);
        newValue.graphTemplateHooks.afterSave.unsubscribe(token);
        newValue.graph.hooks.load.unsubscribe(token);
        newValue.graph.hooks.save.unsubscribe(token);
      }
      if (newValue) {
        newValue.nodeHooks.beforeLoad.subscribe(token, (state, node) => {
          node.position = state.position ?? { x: 0, y: 0 };
          node.width = state.width ?? settings.nodes.defaultWidth;
          node.twoColumn = state.twoColumn ?? false;
          return state;
        });
        newValue.nodeHooks.afterSave.subscribe(token, (state, node) => {
          state.position = node.position;
          state.width = node.width;
          state.twoColumn = node.twoColumn;
          return state;
        });
        newValue.graphTemplateHooks.beforeLoad.subscribe(token, (state, template) => {
          template.panning = state.panning;
          template.scaling = state.scaling;
          return state;
        });
        newValue.graphTemplateHooks.afterSave.subscribe(token, (state, template) => {
          state.panning = template.panning;
          state.scaling = template.scaling;
          return state;
        });
        newValue.graph.hooks.load.subscribe(token, (state, graph) => {
          graph.panning = state.panning;
          graph.scaling = state.scaling;
          return state;
        });
        newValue.graph.hooks.save.subscribe(token, (state, graph) => {
          state.panning = graph.panning;
          state.scaling = graph.scaling;
          return state;
        });
        newValue.graphEvents.beforeAddNode.subscribe(
          token,
          (node) => setViewNodeProperties(node, { defaultWidth: settings.nodes.defaultWidth })
        );
        editor.value.registerNodeType(SubgraphInputNode, { category: "Subgraphs" });
        editor.value.registerNodeType(SubgraphOutputNode, { category: "Subgraphs" });
        switchGraph(newValue.graph);
      }
    },
    { immediate: true }
  );
  return reactive({
    editor,
    displayedGraph,
    isSubgraph,
    settings,
    commandHandler,
    history,
    clipboard,
    hooks,
    switchGraph
  });
}
var components = Object.freeze(Object.defineProperty({
  __proto__: null,
  Connection: ConnectionView,
  ConnectionWrapper,
  ContextMenu: _sfc_main$x,
  Minimap: _sfc_main$p,
  Node: _sfc_main$u,
  NodeInterface: _sfc_main$v,
  NodePalette: _sfc_main$n,
  Sidebar,
  TemporaryConnection
}, Symbol.toStringTag, { value: "Module" }));

export {
  isInputElement,
  getNodePosition,
  setNodePosition,
  providePlugin,
  useViewModel,
  useGraph,
  useDragMove,
  useNodeCategories,
  useTransform,
  TemporaryConnectionState,
  provideTemporaryConnection,
  useTemporaryConnection,
  getDomElementOfNode,
  getDomElements,
  getPortCoordinates,
  _sfc_main$k,
  useCommandHandler,
  ButtonInterfaceComponent,
  ButtonInterface,
  _sfc_main$i,
  CheckboxInterface,
  IntegerInterfaceComponent,
  IntegerInterface,
  _sfc_main$f,
  NumberInterface,
  SelectInterfaceComponent,
  SelectInterface,
  SliderInterfaceComponent,
  SliderInterface,
  TextInterface,
  TextInputInterfaceComponent,
  TextInputInterface,
  TextareaInputInterfaceComponent,
  TextareaInputInterface,
  displayInSidebar,
  commandList,
  TOOLBAR_COMMANDS,
  DEFAULT_TOOLBAR_COMMANDS,
  TOOLBAR_SUBGRAPH_COMMANDS,
  DEFAULT_TOOLBAR_SUBGRAPH_COMMANDS,
  useBaklava,
  components
};
//# sourceMappingURL=chunk-2QXZYFLU.js.map
