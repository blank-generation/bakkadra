import {
  BaseEngine,
  CycleError,
  DependencyEngine,
  EngineStatus,
  allowMultipleConnections,
  applyResult,
  containsCycle,
  sortTopologically
} from "./chunk-HIIZSH3Q.js";
import {
  ButtonInterface,
  ButtonInterfaceComponent,
  CheckboxInterface,
  DEFAULT_TOOLBAR_COMMANDS,
  DEFAULT_TOOLBAR_SUBGRAPH_COMMANDS,
  IntegerInterface,
  IntegerInterfaceComponent,
  NumberInterface,
  SelectInterface,
  SelectInterfaceComponent,
  SliderInterface,
  SliderInterfaceComponent,
  TOOLBAR_COMMANDS,
  TOOLBAR_SUBGRAPH_COMMANDS,
  TemporaryConnectionState,
  TextInputInterface,
  TextInputInterfaceComponent,
  TextInterface,
  TextareaInputInterface,
  TextareaInputInterfaceComponent,
  _sfc_main$f,
  _sfc_main$i,
  _sfc_main$k,
  commandList,
  components,
  displayInSidebar,
  getDomElementOfNode,
  getDomElements,
  getNodePosition,
  getPortCoordinates,
  isInputElement,
  providePlugin,
  provideTemporaryConnection,
  setNodePosition,
  useBaklava,
  useCommandHandler,
  useDragMove,
  useGraph,
  useNodeCategories,
  useTemporaryConnection,
  useTransform,
  useViewModel
} from "./chunk-2QXZYFLU.js";
import "./chunk-FIAHBV72.js";
import {
  AbstractNode,
  Connection,
  DummyConnection,
  DynamicNode,
  Editor,
  GRAPH_INPUT_NODE_TYPE,
  GRAPH_NODE_TYPE_PREFIX,
  GRAPH_OUTPUT_NODE_TYPE,
  Graph,
  GraphInputNode,
  GraphOutputNode,
  GraphTemplate,
  Node,
  NodeInterface,
  createGraphNodeType,
  defineDynamicNode,
  defineNode,
  getGraphNodeTypeString
} from "./chunk-7FQOAGDZ.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@baklavajs/interface-types/dist/esm/index.js
var NodeInterfaceType = class {
  constructor(name) {
    this.name = name;
    this.conversions = [];
  }
  /**
   * A conversion makes it possible to connect two node interfaces although they have different types.
   * @param to Type to convert to
   * @param transformationFunction
   * Will be called to transform the value from one type to another.
   * A transformation to convert the type `string` to `number` could be `parseInt`.
   *
   * @returns the instance the method was called on for chaining
   */
  addConversion(to, transformationFunction = (value) => value) {
    this.conversions.push({
      targetType: to.name,
      transformationFunction
    });
    return this;
  }
};
function setType(intf, type) {
  intf.type = type.name;
}
function setTypeForMultipleConnections(intf, type) {
  intf.type = type.name;
}
function getType(intf) {
  return intf.type;
}
var BaklavaInterfaceTypes = class {
  constructor(editor, options) {
    this.types = /* @__PURE__ */ new Map();
    this.editor = editor;
    this.editor.graphEvents.checkConnection.subscribe(this, ({ from, to }, prevent) => {
      const fromType = from.type;
      const toType = to.type;
      if (!fromType || !toType) {
        return;
      } else if (!this.canConvert(fromType, toType)) {
        return prevent();
      }
    });
    if (options === null || options === void 0 ? void 0 : options.engine) {
      options.engine.hooks.transferData.subscribe(this, (value, connection) => {
        const fromType = connection.from.type;
        const toType = connection.to.type;
        if (!fromType || !toType) {
          return value;
        }
        return this.convert(fromType, toType, value);
      });
    }
    if (options === null || options === void 0 ? void 0 : options.viewPlugin) {
      options.viewPlugin.hooks.renderInterface.subscribe(this, ({ intf, el }) => {
        if (intf.type) {
          el.setAttribute("data-interface-type", intf.type);
        }
        return { intf, el };
      });
    }
  }
  /**
   * Add a new node interface type
   * @param types The types to add
   */
  addTypes(...types) {
    types.forEach((t) => {
      this.types.set(t.name, t);
    });
    return this;
  }
  getConversion(from, to) {
    var _a, _b;
    return (_b = (_a = this.types.get(from)) === null || _a === void 0 ? void 0 : _a.conversions.find((c) => c.targetType === to)) !== null && _b !== void 0 ? _b : null;
  }
  canConvert(from, to) {
    return from === to || this.types.has(from) && this.types.get(from).conversions.some((c) => c.targetType === to);
  }
  convert(from, to, value) {
    if (from === to) {
      return value;
    } else {
      const c = this.getConversion(from, to);
      if (c) {
        return c.transformationFunction(value);
      } else {
        throw Error(`Can not convert from "${from}" to "${to}"`);
      }
    }
  }
};
export {
  AbstractNode,
  _sfc_main$k as BaklavaEditor,
  BaklavaInterfaceTypes,
  BaseEngine,
  ButtonInterface,
  ButtonInterfaceComponent,
  CheckboxInterface,
  _sfc_main$i as CheckboxInterfaceComponent,
  commandList as Commands,
  components as Components,
  Connection,
  CycleError,
  DEFAULT_TOOLBAR_COMMANDS,
  DEFAULT_TOOLBAR_SUBGRAPH_COMMANDS,
  DependencyEngine,
  DummyConnection,
  DynamicNode,
  Editor,
  _sfc_main$k as EditorComponent,
  EngineStatus,
  GRAPH_INPUT_NODE_TYPE,
  GRAPH_NODE_TYPE_PREFIX,
  GRAPH_OUTPUT_NODE_TYPE,
  Graph,
  GraphInputNode,
  GraphOutputNode,
  GraphTemplate,
  IntegerInterface,
  IntegerInterfaceComponent,
  Node,
  NodeInterface,
  NodeInterfaceType,
  NumberInterface,
  _sfc_main$f as NumberInterfaceComponent,
  SelectInterface,
  SelectInterfaceComponent,
  SliderInterface,
  SliderInterfaceComponent,
  TOOLBAR_COMMANDS,
  TOOLBAR_SUBGRAPH_COMMANDS,
  TemporaryConnectionState,
  TextInputInterface,
  TextInputInterfaceComponent,
  TextInterface,
  TextareaInputInterface,
  TextareaInputInterfaceComponent,
  allowMultipleConnections,
  applyResult,
  containsCycle,
  createGraphNodeType,
  defineDynamicNode,
  defineNode,
  displayInSidebar,
  getDomElementOfNode,
  getDomElements,
  getGraphNodeTypeString,
  getNodePosition,
  getPortCoordinates,
  getType,
  isInputElement,
  providePlugin,
  provideTemporaryConnection,
  setNodePosition,
  setType,
  setTypeForMultipleConnections,
  sortTopologically,
  useBaklava,
  useCommandHandler,
  useDragMove,
  useGraph,
  useNodeCategories,
  useTemporaryConnection,
  useTransform,
  useViewModel
};
//# sourceMappingURL=baklavajs.js.map
