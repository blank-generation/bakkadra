import {
  BaklavaEvent,
  DummyConnection,
  DynamicSequentialHook,
  Graph,
  PreventableBaklavaEvent,
  SequentialHook
} from "./chunk-7FQOAGDZ.js";

// node_modules/@baklavajs/engine/dist/esm/applyResult.js
function applyResult(result, editor) {
  const nodeMap = /* @__PURE__ */ new Map();
  editor.graphs.forEach((g) => {
    g.nodes.forEach((n) => nodeMap.set(n.id, n));
  });
  result.forEach((intfValues, nodeId) => {
    const node = nodeMap.get(nodeId);
    if (!node) {
      return;
    }
    intfValues.forEach((value, intfKey) => {
      const intf = node.outputs[intfKey];
      if (!intf) {
        return;
      }
      intf.value = value;
    });
  });
}

// node_modules/@baklavajs/engine/dist/esm/topologicalSorting.js
var CycleError = class extends Error {
  constructor() {
    super("Cycle detected");
  }
};
function isString(v) {
  return typeof v === "string";
}
function sortTopologically(nodesOrGraph, pConnections) {
  const interfaceIdToNodeId = /* @__PURE__ */ new Map();
  const adjacency = /* @__PURE__ */ new Map();
  const connectionsFromNode = /* @__PURE__ */ new Map();
  let nodes;
  let connections;
  if (nodesOrGraph instanceof Graph) {
    nodes = nodesOrGraph.nodes;
    connections = nodesOrGraph.connections;
  } else {
    if (!pConnections) {
      throw new Error("Invalid argument value: expected array of connections");
    }
    nodes = nodesOrGraph;
    connections = pConnections;
  }
  nodes.forEach((n) => {
    Object.values(n.inputs).forEach((intf) => interfaceIdToNodeId.set(intf.id, n.id));
    Object.values(n.outputs).forEach((intf) => interfaceIdToNodeId.set(intf.id, n.id));
  });
  nodes.forEach((n) => {
    const connectionsFromCurrentNode = connections.filter((c) => c.from && interfaceIdToNodeId.get(c.from.id) === n.id);
    const adjacentNodes = new Set(connectionsFromCurrentNode.map((c) => interfaceIdToNodeId.get(c.to.id)).filter(isString));
    adjacency.set(n.id, adjacentNodes);
    connectionsFromNode.set(n, connectionsFromCurrentNode);
  });
  const startNodes = nodes.slice();
  connections.forEach((c) => {
    const index = startNodes.findIndex((n) => interfaceIdToNodeId.get(c.to.id) === n.id);
    if (index >= 0) {
      startNodes.splice(index, 1);
    }
  });
  const sorted = [];
  while (startNodes.length > 0) {
    const n = startNodes.pop();
    sorted.push(n);
    const nodesConnectedFromN = adjacency.get(n.id);
    while (nodesConnectedFromN.size > 0) {
      const mId = nodesConnectedFromN.values().next().value;
      nodesConnectedFromN.delete(mId);
      if (Array.from(adjacency.values()).every((connectedNodes) => !connectedNodes.has(mId))) {
        const m = nodes.find((node) => node.id === mId);
        startNodes.push(m);
      }
    }
  }
  if (Array.from(adjacency.values()).some((c) => c.size > 0)) {
    throw new CycleError();
  }
  return {
    calculationOrder: sorted,
    connectionsFromNode,
    interfaceIdToNodeId
  };
}
function containsCycle(nodesOrGraph, connections) {
  try {
    sortTopologically(nodesOrGraph, connections);
    return false;
  } catch (err) {
    if (err instanceof CycleError) {
      return true;
    }
    throw err;
  }
}

// node_modules/@baklavajs/engine/dist/esm/baseEngine.js
var EngineStatus;
(function(EngineStatus2) {
  EngineStatus2["Running"] = "Running";
  EngineStatus2["Idle"] = "Idle";
  EngineStatus2["Paused"] = "Paused";
  EngineStatus2["Stopped"] = "Stopped";
})(EngineStatus || (EngineStatus = {}));
var BaseEngine = class {
  get status() {
    if (this.isRunning) {
      return EngineStatus.Running;
    }
    return this.internalStatus;
  }
  constructor(editor) {
    this.editor = editor;
    this.events = {
      /**
       * This event will be called before all the nodes `calculate` functions are called.
       * The argument is the calculationData that the nodes will receive
       */
      beforeRun: new PreventableBaklavaEvent(this),
      /**
       * This event is called as soon as a run is completed.
       * The argument is the result of the calculation.
       */
      afterRun: new BaklavaEvent(this),
      statusChange: new BaklavaEvent(this),
      /**
       * This event is called before a node is calculated.
       * It is not preventable since this would break calculation.
       */
      beforeNodeCalculation: new BaklavaEvent(this),
      /** This event is called after a node has been calculated. */
      afterNodeCalculation: new BaklavaEvent(this)
    };
    this.hooks = {
      gatherCalculationData: new SequentialHook(this),
      transferData: new DynamicSequentialHook()
    };
    this.recalculateOrder = true;
    this.internalStatus = EngineStatus.Stopped;
    this.isRunning = false;
    this.editor.nodeEvents.update.subscribe(this, (data, node) => {
      if (node.graph && !node.graph.loading && node.graph.activeTransactions === 0) {
        this.internalOnChange(node, data !== null && data !== void 0 ? data : void 0);
      }
    });
    this.editor.graphEvents.addNode.subscribe(this, (node, graph) => {
      this.recalculateOrder = true;
      if (!graph.loading && graph.activeTransactions === 0) {
        this.internalOnChange();
      }
    });
    this.editor.graphEvents.removeNode.subscribe(this, (node, graph) => {
      this.recalculateOrder = true;
      if (!graph.loading && graph.activeTransactions === 0) {
        this.internalOnChange();
      }
    });
    this.editor.graphEvents.addConnection.subscribe(this, (c, graph) => {
      this.recalculateOrder = true;
      if (!graph.loading && graph.activeTransactions === 0) {
        this.internalOnChange();
      }
    });
    this.editor.graphEvents.removeConnection.subscribe(this, (c, graph) => {
      this.recalculateOrder = true;
      if (!graph.loading && graph.activeTransactions === 0) {
        this.internalOnChange();
      }
    });
    this.editor.graphHooks.checkConnection.subscribe(this, (c) => this.checkConnection(c.from, c.to));
  }
  /** Start the engine. After started, it will run everytime the graph is changed. */
  start() {
    if (this.internalStatus === EngineStatus.Stopped) {
      this.internalStatus = EngineStatus.Idle;
      this.events.statusChange.emit(this.status);
    }
  }
  /**
   * Temporarily pause the engine.
   * Use this method when you want to update the graph with the calculation results.
   */
  pause() {
    if (this.internalStatus === EngineStatus.Idle) {
      this.internalStatus = EngineStatus.Paused;
      this.events.statusChange.emit(this.status);
    }
  }
  /** Resume the engine from the paused state */
  resume() {
    if (this.internalStatus === EngineStatus.Paused) {
      this.internalStatus = EngineStatus.Idle;
      this.events.statusChange.emit(this.status);
    }
  }
  /** Stop the engine */
  stop() {
    if (this.internalStatus === EngineStatus.Idle || this.internalStatus === EngineStatus.Paused) {
      this.internalStatus = EngineStatus.Stopped;
      this.events.statusChange.emit(this.status);
    }
  }
  /**
   * Calculate all nodes once.
   * This will automatically calculate the node calculation order if necessary and
   * transfer values between connected node interfaces.
   * @param calculationData The data which is provided to each node's `calculate` method
   * @param calculationArgs Additional data which is only provided to the engine
   * @returns A promise that resolves to either
   * - a map from each node's id to its calculated value (what the calculation function of the node returned)
   * - null if the calculation was prevented from the beforeRun event
   */
  async runOnce(calculationData, ...args) {
    if (this.events.beforeRun.emit(calculationData).prevented) {
      return null;
    }
    try {
      this.isRunning = true;
      this.events.statusChange.emit(this.status);
      if (this.recalculateOrder) {
        this.calculateOrder();
      }
      const result = await this.execute(calculationData, ...args);
      this.events.afterRun.emit(result);
      return result;
    } finally {
      this.isRunning = false;
      this.events.statusChange.emit(this.status);
    }
  }
  /** Check whether a connection can be created.
   * A connection can not be created when it would result in a cyclic graph.
   * @param from The interface from which the connection would start
   * @param to The interface where the connection would end
   * @returns Whether the connection can be created
   */
  checkConnection(from, to) {
    if (from.templateId) {
      const newFrom = this.findInterfaceByTemplateId(this.editor.graph.nodes, from.templateId);
      if (!newFrom) {
        return { connectionAllowed: true, connectionsInDanger: [] };
      }
      from = newFrom;
    }
    if (to.templateId) {
      const newTo = this.findInterfaceByTemplateId(this.editor.graph.nodes, to.templateId);
      if (!newTo) {
        return { connectionAllowed: true, connectionsInDanger: [] };
      }
      to = newTo;
    }
    const dc = new DummyConnection(from, to);
    let copy = this.editor.graph.connections.slice();
    if (!to.allowMultipleConnections) {
      copy = copy.filter((conn) => conn.to !== to);
    }
    copy.push(dc);
    if (containsCycle(this.editor.graph.nodes, copy)) {
      return { connectionAllowed: false, connectionsInDanger: [] };
    }
    return {
      connectionAllowed: true,
      connectionsInDanger: to.allowMultipleConnections ? [] : this.editor.graph.connections.filter((c) => c.to === to)
    };
  }
  /**
   * Force the engine to recalculate the node execution order before the next run.
   * This is normally done automatically. Use this method if the
   * default change detection does not work in your scenario.
   */
  calculateOrder() {
    this.recalculateOrder = true;
  }
  /**
   * Use the `gatherCalculationData` hook to get the calculation data
   * @param args The calculation arguments with which the engine's calculate method will be called (in addition to the `calculationData`)
   * @returns The calculation result
   */
  async calculateWithoutData(...args) {
    const calculationData = this.hooks.gatherCalculationData.execute(void 0);
    return await this.runOnce(calculationData, ...args);
  }
  /**
   * Validate the result of a node's `calculate` method. A result is valid if:
   * - is has the correct format (it must be an object, where the key is the interface key and the value is the output value for that interface)
   * - every output interface has a value assigned to it (null and undefined are also valid, but the key must exist in the object)
   * @param node The node which produced the output data
   * @param output The result of the node's `calculate` method
   */
  validateNodeCalculationOutput(node, output) {
    if (typeof output !== "object") {
      throw new Error(`Invalid calculation return value from node ${node.id} (type ${node.type})`);
    }
    Object.keys(node.outputs).forEach((k) => {
      if (!(k in output)) {
        throw new Error(`Calculation return value from node ${node.id} (type ${node.type}) is missing key "${k}"`);
      }
    });
  }
  internalOnChange(updatedNode, data) {
    if (this.internalStatus === EngineStatus.Idle) {
      this.onChange(this.recalculateOrder, updatedNode, data);
    }
  }
  findInterfaceByTemplateId(nodes, templateId) {
    for (const n of nodes) {
      for (const intf of [...Object.values(n.inputs), ...Object.values(n.outputs)]) {
        if (intf.templateId === templateId) {
          return intf;
        }
      }
    }
    return null;
  }
};

// node_modules/@baklavajs/engine/dist/esm/dependencyEngine.js
var allowMultipleConnections = (intf) => {
  intf.allowMultipleConnections = true;
};
var DependencyEngine = class extends BaseEngine {
  constructor(editor) {
    super(editor);
    this.order = /* @__PURE__ */ new Map();
  }
  start() {
    super.start();
    this.recalculateOrder = true;
    void this.calculateWithoutData();
  }
  async runGraph(graph, inputs, calculationData) {
    if (!this.order.has(graph.id)) {
      this.order.set(graph.id, sortTopologically(graph));
    }
    const { calculationOrder, connectionsFromNode } = this.order.get(graph.id);
    const result = /* @__PURE__ */ new Map();
    for (const n of calculationOrder) {
      const inputsForNode = {};
      Object.entries(n.inputs).forEach(([k, v]) => {
        inputsForNode[k] = this.getInterfaceValue(inputs, v.id);
      });
      this.events.beforeNodeCalculation.emit({ inputValues: inputsForNode, node: n });
      let r;
      if (n.calculate) {
        r = await n.calculate(inputsForNode, { globalValues: calculationData, engine: this });
      } else {
        r = {};
        for (const [k, intf] of Object.entries(n.outputs)) {
          r[k] = this.getInterfaceValue(inputs, intf.id);
        }
      }
      this.validateNodeCalculationOutput(n, r);
      this.events.afterNodeCalculation.emit({ outputValues: r, node: n });
      result.set(n.id, new Map(Object.entries(r)));
      if (connectionsFromNode.has(n)) {
        connectionsFromNode.get(n).forEach((c) => {
          var _a;
          const intfKey = (_a = Object.entries(n.outputs).find(([, intf]) => intf.id === c.from.id)) === null || _a === void 0 ? void 0 : _a[0];
          if (!intfKey) {
            throw new Error(`Could not find key for interface ${c.from.id}
This is likely a Baklava internal issue. Please report it on GitHub.`);
          }
          const v = this.hooks.transferData.execute(r[intfKey], c);
          if (c.to.allowMultipleConnections) {
            if (inputs.has(c.to.id)) {
              inputs.get(c.to.id).push(v);
            } else {
              inputs.set(c.to.id, [v]);
            }
          } else {
            inputs.set(c.to.id, v);
          }
        });
      }
    }
    return result;
  }
  async execute(calculationData) {
    if (this.recalculateOrder) {
      this.order.clear();
      this.recalculateOrder = false;
    }
    const inputValues = this.getInputValues(this.editor.graph);
    return await this.runGraph(this.editor.graph, inputValues, calculationData);
  }
  getInputValues(graph) {
    const inputValues = /* @__PURE__ */ new Map();
    for (const n of graph.nodes) {
      Object.values(n.inputs).forEach((ni) => {
        if (ni.connectionCount === 0) {
          inputValues.set(ni.id, ni.value);
        }
      });
      if (!n.calculate) {
        Object.values(n.outputs).forEach((ni) => {
          inputValues.set(ni.id, ni.value);
        });
      }
    }
    return inputValues;
  }
  onChange(recalculateOrder) {
    this.recalculateOrder = recalculateOrder || this.recalculateOrder;
    void this.calculateWithoutData();
  }
  getInterfaceValue(values, id) {
    if (!values.has(id)) {
      throw new Error(`Could not find value for interface ${id}
This is likely a Baklava internal issue. Please report it on GitHub.`);
    }
    return values.get(id);
  }
};

export {
  applyResult,
  CycleError,
  sortTopologically,
  containsCycle,
  EngineStatus,
  BaseEngine,
  allowMultipleConnections,
  DependencyEngine
};
//# sourceMappingURL=chunk-HIIZSH3Q.js.map
